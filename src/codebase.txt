=== ./lib/db.js ===
import { DATABASE } from "./constants";

export const db = {
  open() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DATABASE.NAME, DATABASE.VERSION);

      request.onupgradeneeded = (e) => {
        const database = e.target.result;
        const transaction = e.target.transaction;
        let store;

        if (database.objectStoreNames.contains(DATABASE.STORE_NAME)) {
          store = transaction.objectStore(DATABASE.STORE_NAME);
        } else {
          store = database.createObjectStore(DATABASE.STORE_NAME, {
            keyPath: "file",
          });
        }

        if (!store.indexNames.contains("artist")) {
          store.createIndex("artist", "artist", { unique: false });
        }
        if (!store.indexNames.contains("album")) {
          store.createIndex("album", "album", { unique: false });
        }
        if (!store.indexNames.contains("genre")) {
          store.createIndex("genre", "genre", { unique: false });
        }
        if (!store.indexNames.contains("album_artist")) {
          store.createIndex("album_artist", "album_artist", { unique: false });
        }
      };

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  async clear() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readwrite");
      tx.objectStore(DATABASE.STORE_NAME).clear();
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },

  async bulkAdd(tracks) {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readwrite");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      tracks.forEach((track) => store.put(track));
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },

  async getFilesMap(files) {
    if (!files || files.length === 0) return new Map();
    const database = await this.open();
    return new Promise((resolve) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const resultMap = new Map();
      let loaded = 0;
      files.forEach((rawFile) => {
        const searchKey = rawFile.normalize("NFC").trim();
        const req = store.get(searchKey);
        req.onsuccess = (e) => {
          if (e.target.result) resultMap.set(rawFile, e.target.result);
          loaded++;
          if (loaded === files.length) resolve(resultMap);
        };
        req.onerror = () => {
          loaded++;
          if (loaded === files.length) resolve(resultMap);
        };
      });
    });
  },

  async getArtists() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const uniqueMap = new Map();
      const request = store.openCursor();
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const t = cursor.value;
          const effectiveName = t.album_artist || t.artist;
          if (effectiveName && !uniqueMap.has(effectiveName)) {
            uniqueMap.set(effectiveName, {
              name: effectiveName,
              file: t.file,
              thumbHash: t.thumbHash,
            });
          }
          cursor.continue();
        } else {
          const sorted = Array.from(uniqueMap.values()).sort((a, b) =>
            a.name.localeCompare(b.name, undefined, { sensitivity: "base" }),
          );
          resolve(sorted);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getAlbums() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("album");
      const albums = [];
      const request = index.openCursor(null, "nextunique");
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const t = cursor.value;
          albums.push({
            name: t.album,
            artist: t.album_artist || t.artist,
            file: t.file,
            thumbHash: t.thumbHash,
            qualityBadge: t.qualityBadge,
            year: t.year || 0,
          });
          cursor.continue();
        } else {
          resolve(albums);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getArtistAlbums(artistName) {
    if (!artistName) return [];
    const database = await this.open();
    const safeArtist = artistName.normalize("NFC").trim();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const p1 = new Promise((res) => {
        if (store.indexNames.contains("album_artist")) {
          store
            .index("album_artist")
            .getAll(IDBKeyRange.only(safeArtist)).onsuccess = (e) =>
            res(e.target.result);
        } else res([]);
      });
      const p2 = new Promise((res) => {
        store.index("artist").getAll(IDBKeyRange.only(safeArtist)).onsuccess = (
          e,
        ) => res(e.target.result);
      });
      Promise.all([p1, p2])
        .then(([r1, r2]) => {
          const allTracks = [...r1, ...r2];
          const uniqueAlbums = [];
          const seenAlbums = new Set();
          allTracks.forEach((t) => {
            if (!seenAlbums.has(t.album)) {
              seenAlbums.add(t.album);
              uniqueAlbums.push({
                name: t.album,
                artist: t.album_artist || t.artist,
                file: t.file,
                thumbHash: t.thumbHash,
                qualityBadge: t.qualityBadge,
                year: t.year || 0,
              });
            }
          });
          resolve(uniqueAlbums);
        })
        .catch((err) => reject(err));
    });
  },

  async getAlbumTracks(albumName, artistFilter = null) {
    const database = await this.open();
    // Нормализуем входные данные
    const safeAlbum = albumName.normalize("NFC").trim();
    const safeArtist = artistFilter
      ? artistFilter.normalize("NFC").trim()
      : null;

    console.log(
      `[DB] getAlbumTracks called. Album: "${safeAlbum}", FilterArtist: "${safeArtist}"`,
    );

    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("album");

      // 1. Получаем ВСЕ треки с таким названием альбома (например, "Film Music")
      const range = IDBKeyRange.only(safeAlbum);
      const request = index.getAll(range);

      request.onsuccess = () => {
        let tracks = request.result;
        console.log(
          `[DB] Found ${tracks.length} raw tracks for album "${safeAlbum}"`,
        );

        // 2. Если указан фильтр по артисту, оставляем только его треки
        if (safeArtist) {
          const beforeCount = tracks.length;
          tracks = tracks.filter((t) => {
            const tArtist = (t.artist || "").normalize("NFC").trim();
            const tAlbumArtist = (t.album_artist || "").normalize("NFC").trim();

            const match = tArtist === safeArtist || tAlbumArtist === safeArtist;

            if (!match) {
            }
            return match;
          });
          console.log(
            `[DB] After artist filter: ${tracks.length} tracks (Removed ${beforeCount - tracks.length})`,
          );
        } else {
          console.log("[DB] No artist filter provided. Returning all tracks.");
        }

        // 3. Сортировка
        tracks.sort((a, b) => {
          const discA = parseInt(a.disc || 1);
          const discB = parseInt(b.disc || 1);
          if (discA !== discB) return discA - discB;
          const trA = parseInt(a.track || 0);
          const trB = parseInt(b.track || 0);
          return trA - trB;
        });
        resolve(tracks);
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getGenres() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("genre");
      const genres = [];
      const request = index.openKeyCursor(null, "nextunique");
      request.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          genres.push(cursor.key);
          cursor.continue();
        } else {
          resolve(genres);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getGenreTracks(genre) {
    const database = await this.open();
    const safeGenre = genre.normalize("NFC").trim();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("genre");
      const request = index.getAll(IDBKeyRange.only(safeGenre));
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  async search(query) {
    if (!query) return [];
    const q = query.toLowerCase().normalize("NFC").trim();
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const results = [];
      const MAX_RESULTS = 100;
      const request = store.openCursor();
      request.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          const t = cursor.value;
          const match =
            (t.title && t.title.toLowerCase().includes(q)) ||
            (t.artist && t.artist.toLowerCase().includes(q)) ||
            (t.album && t.album.toLowerCase().includes(q)) ||
            (t.album_artist && t.album_artist.toLowerCase().includes(q));
          if (match) {
            results.push(t);
          }
          if (results.length >= MAX_RESULTS) {
            resolve(results);
            return;
          }
          cursor.continue();
        } else {
          resolve(results);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },
};

=== ./lib/index.js ===
// 1. Экспортируем всё для MPD (управление)
// Убедитесь, что в lib/mpd/index.js больше НЕТ syncLibrary
export * from "./mpd";

// 2. Экспортируем всё для API (синхронизация)
export { ApiActions } from "./api";

// Helper для удобного импорта одиночной функции
import { ApiActions } from "./api";
export const syncLibrary = ApiActions.syncLibrary;

=== ./lib/router.js ===
import { get } from "svelte/store";
import {
  activeMenuTab,
  navigationStack,
  searchQuery,
  consumeRouteData,
} from "./store";

export const Router = {
  init() {
    this.handleHashChange();
    window.addEventListener("hashchange", () => this.handleHashChange());
  },

  handleHashChange() {
    let raw = window.location.hash.slice(1);
    while (raw.startsWith("/")) {
      raw = raw.slice(1);
    }

    if (!raw) {
      if (get(navigationStack).length > 1 || get(activeMenuTab) === "search") {
        this.setRootTab("artists");
        window.location.hash = "/artists";
      }
      return;
    }

    const parts = raw.split("/").map(decodeURIComponent);
    const route = parts[0];

    let data = consumeRouteData();

    if (!data) {
      if (parts.length > 1) {
        if (route === "album" && parts.length >= 3) {
          // ФОРМАТ: #/album/Artist Name/Album Name
          data = { artist: parts[1], name: parts[2] };
        } else if (route === "artist" && parts.length >= 2) {
          data = { name: parts[1] };
        } else {
          // Старый формат (fallback)
          data = { name: parts[1], displayName: parts[1] };
        }
      }
    }

    console.log(`[Router] Navigating: ${route}`, data);

    switch (route) {
      case "queue":
        this.setRootTab("queue");
        break;
      case "radio":
        this.setRootTab("radio");
        break;
      case "playlists":
        this.setRootTab("playlists");
        break;
      case "favorites":
        activeMenuTab.set("favorites");
        navigationStack.set([
          { view: "root" },
          { view: "details", data: { name: "Favorites" } },
        ]);
        break;

      case "artists":
        this.setRootTab("artists");
        break;
      case "albums":
        this.setRootTab("albums");
        break;
      case "search":
        activeMenuTab.set("search");
        if (parts[1]) searchQuery.set(parts[1]);
        navigationStack.set([{ view: "root" }]);
        break;

      case "album":
        activeMenuTab.set("albums");
        navigationStack.set([
          { view: "root" },
          { view: "tracks_by_album", data: data },
        ]);
        break;

      case "artist":
        activeMenuTab.set("artists");
        navigationStack.set([
          { view: "root" },
          { view: "albums_by_artist", data: data },
        ]);
        break;

      case "playlist":
        activeMenuTab.set("playlists");
        navigationStack.set([
          { view: "root" },
          { view: "details", data: data },
        ]);
        break;

      default:
        this.setRootTab("artists");
        break;
    }
  },

  setRootTab(tab) {
    activeMenuTab.set(tab);
    navigationStack.set([{ view: "root" }]);
  },

  updateUrl(view, data) {
    let newPath = "";

    if (view === "root") {
      const tab = get(activeMenuTab);
      if (tab === "search") {
        const q = get(searchQuery);
        newPath = q ? `search/${encodeURIComponent(q)}` : "search";
      } else {
        newPath = tab;
      }
    } else if (view === "details") {
      const name = data.name || data;
      newPath =
        name === "Favorites"
          ? "favorites"
          : `playlist/${encodeURIComponent(name)}`;
    } else if (view === "albums_by_artist") {
      const name = data.name || data;
      newPath = `artist/${encodeURIComponent(name)}`;
    } else if (view === "tracks_by_album") {
      const name = data.name || data;
      const artist = data.artist;

      if (artist) {
        newPath = `album/${encodeURIComponent(artist)}/${encodeURIComponent(name)}`;
      } else {
        newPath = `album/${encodeURIComponent(name)}`;
      }
    } else if (view === "queue") {
      newPath = "queue";
    }

    if (newPath) {
      const nextHash = `#/${newPath}`;
      if (
        decodeURIComponent(window.location.hash) !==
        decodeURIComponent(nextHash)
      ) {
        window.location.hash = `/${newPath}`;
      }
    }
  },
};

=== ./lib/playlistDrag.js ===
import { writable, get } from "svelte/store";
import { tick } from "svelte";

const SCROLL_ZONE_PX = 100;
const SCROLL_SPEED_BASE = 5;
const SCROLL_SPEED_MAX = 25;
const DRAG_THRESHOLD = 3;

export function createPlaylistDrag({ tracksStore, onMoveTrack }) {
  const isDragging = writable(false);
  const isDropping = writable(false);
  const isReordering = writable(false);

  const draggingIndex = writable(null);
  const hoverIndex = writable(null);
  const justDroppedIndex = writable(null);

  const ghostCoords = writable({
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    grabOffsetX: 0,
    grabOffsetY: 0,
  });
  const draggedItemData = writable(null);

  let isDown = false;
  let startX = 0;
  let startY = 0;
  let currentX = 0;
  let currentY = 0;

  const refs = {
    scrollContainer: null,
    listBodyContainer: null,
  };

  let scrollInterval = null;

  function onDragInit(event, index, track) {
    const e = event.detail;
    if (e.button === 2) return;
    if (window.getSelection) window.getSelection().removeAllRanges();

    if (!refs.scrollContainer) return;

    const rows = refs.scrollContainer.querySelectorAll(".row-wrapper");
    const targetRow = rows[index];
    if (!targetRow) return;

    const rect = targetRow.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    const grabOffsetX = clientX - rect.left;
    const grabOffsetY = clientY - rect.top;

    isDown = true;
    isDragging.set(false);
    isDropping.set(false);

    startX = clientX;
    startY = clientY;
    currentX = clientX;
    currentY = clientY;

    draggingIndex.set(index);
    hoverIndex.set(index);
    draggedItemData.set(track);
    justDroppedIndex.set(null);

    ghostCoords.set({
      x: clientX,
      y: clientY,
      width: rect.width,
      height: rect.height,
      grabOffsetX,
      grabOffsetY,
    });
  }

  function onPointerMove(e) {
    if (!isDown || get(isDropping)) return;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    if (!get(isDragging)) {
      const dx = Math.abs(clientX - startX);
      const dy = Math.abs(clientY - startY);
      if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) return;
      isDragging.set(true);
    }

    if (e.cancelable) e.preventDefault();

    currentX = clientX;
    currentY = clientY;

    ghostCoords.update((c) => ({ ...c, x: currentX, y: currentY }));

    handleAutoScroll(currentY);
    calculateHoverIndex();
  }

  function calculateHoverIndex() {
    if (!refs.listBodyContainer) return;

    const listRect = refs.listBodyContainer.getBoundingClientRect();
    const gCoords = get(ghostCoords);

    const mouseRelativeY = currentY - listRect.top;
    const ghostCenterInList =
      mouseRelativeY - gCoords.grabOffsetY + gCoords.height / 2;

    const tracksCount = get(tracksStore).length;

    if (ghostCenterInList < 0) {
      hoverIndex.set(0);
      return;
    }
    if (ghostCenterInList > listRect.height) {
      hoverIndex.set(tracksCount);
      return;
    }

    const rows = Array.from(
      refs.listBodyContainer.querySelectorAll(".row-wrapper"),
    );
    let bestIndex = -1;
    let minDistance = Infinity;

    // Мы должны учитывать расстояние до оригинального слота, чтобы можно было вернуть трек назад.
    rows.forEach((row, idx) => {
      const rowCenterY = row.offsetTop + row.offsetHeight / 2;
      const dist = Math.abs(ghostCenterInList - rowCenterY);

      if (dist < minDistance) {
        minDistance = dist;
        bestIndex = idx;
      }
    });

    if (bestIndex !== -1) {
      hoverIndex.set(bestIndex);
    }
  }

  function onPointerUp(e) {
    if (!isDown) return;
    isDown = false;

    if (!get(isDragging)) {
      cancelDrag();
      return;
    }
    commitDrop();
  }

  async function commitDrop() {
    stopAutoScroll();

    // 1. Фаза полета
    isDragging.set(false);
    isDropping.set(true);

    const finalHoverIndex = get(hoverIndex);
    const gCoords = get(ghostCoords);

    // Расчет координат для анимации полета (без изменений)
    if (refs.listBodyContainer && finalHoverIndex !== null) {
      const rows = refs.listBodyContainer.querySelectorAll(".row-wrapper");
      const targetRow = rows[finalHoverIndex];
      if (targetRow) {
        const listRect = refs.listBodyContainer.getBoundingClientRect();
        const targetTopScreen = listRect.top + targetRow.offsetTop;
        const targetLeftScreen = listRect.left + targetRow.offsetLeft;
        ghostCoords.update((c) => ({
          ...c,
          y: targetTopScreen + c.grabOffsetY,
          x: targetLeftScreen + c.grabOffsetX,
        }));
      }
    }

    // Ждем анимацию полета
    await new Promise((resolve) => setTimeout(resolve, 200));

    // Блокируем анимации
    isReordering.set(true);

    // Ждем, пока Svelte добавит класс в DOM
    await tick();

    // Без этого на мобилке класс применяется слишком поздно.
    if (refs.listBodyContainer) {
      const _forceReflow = refs.listBodyContainer.offsetHeight;
    }

    // Теперь, когда анимации гарантированно выключены, меняем всё разом.
    const currentDragIdx = get(draggingIndex);
    const maxIndex = get(tracksStore).length;
    let validIndex = Math.max(0, Math.min(finalHoverIndex, maxIndex));
    let insertAt = validIndex;

    if (currentDragIdx !== null && currentDragIdx !== validIndex) {
      const tracks = [...get(tracksStore)];
      const [item] = tracks.splice(currentDragIdx, 1);

      insertAt = Math.max(0, Math.min(insertAt, tracks.length));
      tracks.splice(insertAt, 0, item);

      // Обновляем массив
      tracksStore.set(tracks);

      if (onMoveTrack) {
        onMoveTrack(currentDragIdx, insertAt);
      }
    }

    // Мгновенно сбрасываем индексы.
    draggingIndex.set(null);
    hoverIndex.set(null);
    draggedItemData.set(null);
    isDropping.set(false);

    // Включаем анимацию приземления для нового элемента
    const droppedAt = currentDragIdx !== validIndex ? insertAt : currentDragIdx;
    justDroppedIndex.set(droppedAt);

    // Ждем отрисовки нового состояния DOM
    await tick();

    // Возвращаем анимации обратно
    requestAnimationFrame(() => {
      isReordering.set(false);
      setTimeout(() => {
        justDroppedIndex.set(null);
      }, 300);
    });
  }
  function cancelDrag() {
    isDown = false;
    resetDragState();
  }

  function resetDragState() {
    isDragging.set(false);
    isDropping.set(false);
    draggingIndex.set(null);
    hoverIndex.set(null);
    draggedItemData.set(null);
    stopAutoScroll();
  }

  function handleAutoScroll(y) {
    if (!refs.scrollContainer) return;
    const { top, bottom } = refs.scrollContainer.getBoundingClientRect();
    const distTop = y - top;
    const distBottom = bottom - y;

    stopAutoScroll();
    let speed = 0;

    if (distTop < SCROLL_ZONE_PX && distTop > 0) {
      const intensity = 1 - distTop / SCROLL_ZONE_PX;
      speed = -(SCROLL_SPEED_BASE + SCROLL_SPEED_MAX * (intensity * intensity));
    } else if (distBottom < SCROLL_ZONE_PX && distBottom > 0) {
      const intensity = 1 - distBottom / SCROLL_ZONE_PX;
      speed = SCROLL_SPEED_BASE + SCROLL_SPEED_MAX * (intensity * intensity);
    }

    if (speed !== 0) startAutoScroll(speed);
  }

  function startAutoScroll(speed) {
    if (scrollInterval) return;
    scrollInterval = requestAnimationFrame(function tickLoop() {
      if (!refs.scrollContainer) return;
      refs.scrollContainer.scrollTop += speed;

      if (get(isDragging)) {
        const fakeEvent = {
          touches: [{ clientX: currentX, clientY: currentY }],
          clientX: currentX,
          clientY: currentY,
          preventDefault: () => {},
        };
        ghostCoords.update((c) => ({ ...c, x: currentX, y: currentY }));
        calculateHoverIndex();

        scrollInterval = requestAnimationFrame(tickLoop);
      }
    });
  }

  function stopAutoScroll() {
    if (scrollInterval) {
      cancelAnimationFrame(scrollInterval);
      scrollInterval = null;
    }
  }

  function getRowStyle(
    index,
    isDraggingVal,
    isDroppingVal,
    dragIdxVal,
    hoverIdxVal,
    isReorderingVal,
  ) {
    // Пусть DOM элементы встанут на свои новые места чисто.
    if (isReorderingVal) return "";

    if (
      (!isDraggingVal && !isDroppingVal) ||
      dragIdxVal === null ||
      hoverIdxVal === null
    )
      return "";

    // Скрытие элемента под пальцем
    if (index === dragIdxVal) {
      return "opacity: 0; pointer-events: none;";
    }

    if (dragIdxVal === hoverIdxVal) return "";

    // Сдвиги
    if (dragIdxVal < hoverIdxVal) {
      if (index > dragIdxVal && index <= hoverIdxVal) {
        return "transform: translateY(-100%);";
      }
    }

    if (dragIdxVal > hoverIdxVal) {
      if (index >= hoverIdxVal && index < dragIdxVal) {
        return "transform: translateY(100%);";
      }
    }
    return "";
  }

  return {
    isDragging,
    isDropping,
    isReordering,
    draggingIndex,
    hoverIndex,
    justDroppedIndex,
    draggedItemData,
    ghostCoords,
    refs,
    onDragInit,
    onPointerMove,
    onPointerUp,
    getRowStyle,
    cancelDrag,
  };
}

=== ./lib/api.js ===
import { get } from "svelte/store";
import { CONFIG } from "../config";
import { API_ENDPOINTS } from "./constants";
import { isSyncingLibrary, showToast, isLoadingRadio, stations } from "./store";
import SyncWorker from "./workers/sync.worker.js?worker";

/**
 * Actions for interacting with the wave-api.php backend.
 */
export const ApiActions = {
  /**
   * Starts library synchronization via Web Worker to prevent UI blocking during large JSON parsing.
   */
  async syncLibrary() {
    if (get(isSyncingLibrary)) return;

    isSyncingLibrary.set(true);
    const worker = new SyncWorker();

    const apiUrl = window.location.origin + "/wave-api.php";

    worker.postMessage({
      type: "START_SYNC",
      payload: {
        url: apiUrl,
      },
    });

    worker.onmessage = (e) => {
      const { type, status, count, message } = e.data;

      if (type === "PROGRESS") {
        const labels = {
          connecting: "Requesting library...",
          downloading: "Downloading data...",
          parsing: "Processing metadata...",
          saving: `Saving ${count} tracks...`,
        };
        if (labels[status]) showToast(labels[status], "info");
      }

      if (type === "DONE") {
        showToast(`Library updated: ${count} tracks`, "success");
        isSyncingLibrary.set(false);
        worker.terminate();
      }

      if (type === "ERROR") {
        console.error("[API] Sync Error:", message);
        showToast(`Sync Failed: ${message}`, "error");
        isSyncingLibrary.set(false);
        worker.terminate();
      }
    };

    worker.onerror = (err) => {
      console.error("[API] Worker crash:", err);
      showToast("Sync worker crashed", "error");
      isSyncingLibrary.set(false);
      worker.terminate();
    };
  },

  /**
   * Loads radio station list and normalizes it for the player.
   */
  async loadRadioStations() {
    if (get(isLoadingRadio)) return;

    isLoadingRadio.set(true);
    try {
      const isDev = import.meta.env.DEV;
      const res = await fetch(API_ENDPOINTS.STATIONS(isDev));

      if (!res.ok) throw new Error("Network error");

      const rawData = await res.json();
      if (rawData.error) throw new Error(rawData.error);
      if (!Array.isArray(rawData)) throw new Error("Invalid response format");

      const normalized = rawData.map((item) => ({
        id: item.id,
        name: item.name,
        file: item.station, // Player expects 'file' for playback
        station: item.station,
        image: item.logo, // Raw value: 'local', URL, or filename
        genre: item.genre || "Radio",
      }));

      // Sort alphabetically by name
      normalized.sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { sensitivity: "base" }),
      );

      stations.set(normalized);
    } catch (e) {
      console.error("[API] Failed to load stations", e);
      showToast("Failed to load radio", "error");
    } finally {
      isLoadingRadio.set(false);
    }
  },
};

=== ./lib/icons.js ===
/**
 * Icon Collection for Wave-UI Moode.
 * Strictly using existing files from ./lib/svg
 */

// Импортируем содержимое файлов как строки (Vite raw import)
import arrowsShuffle2 from "./svg/arrows-shuffle-2.svg?raw";
import brandDeezer from "./svg/brand-deezer.svg?raw";
import chevronCompactDown from "./svg/chevron-compact-down.svg?raw";
import chevronCompactLeft from "./svg/chevron-compact-left.svg?raw";
import chevronLeft from "./svg/chevron-left.svg?raw";
import disc from "./svg/disc.svg?raw";
import gripHorizontal from "./svg/grip-horizontal.svg?raw";
import heartEmpty from "./svg/heart-empty.svg?raw";
import heartFilled from "./svg/heart-filled.svg?raw";
import menu2 from "./svg/menu-2.svg?raw";
import music from "./svg/music.svg?raw";
import playerPause from "./svg/player-pause.svg?raw";
import playerPlayEmpty from "./svg/player-play-empty.svg?raw";
import playerPlayFilled from "./svg/player-play-filled.svg?raw";
import playerSkipBack from "./svg/player-skip-back.svg?raw";
import playerSkipForward from "./svg/player-skip-forward.svg?raw";
import playlist from "./svg/playlist.svg?raw";
import radio from "./svg/radio.svg?raw";
import refresh from "./svg/refresh.svg?raw";
import repeat from "./svg/repeat.svg?raw";
import search from "./svg/search.svg?raw";
import settings from "./svg/settings.svg?raw";
import trash from "./svg/trash.svg?raw";
import volumeFull from "./svg/volume-full.svg?raw";
import volumeMedium from "./svg/volume-medium.svg?raw";
import volumeMute from "./svg/volume-mute.svg?raw";
import volumeOff from "./svg/volume-off.svg?raw";
import x from "./svg/x.svg?raw";
import deviceFloppy from "./svg/device-floppy.svg?raw";
import filePencil from "./svg/file-pencil.svg?raw";
import plus from "./svg/plus.svg?raw";
import circleCheck from "./svg/circle-check.svg?raw";
import dots from "./svg/dots.svg?raw";
import sortDescending from "./svg/sort-descending.svg?raw";
import sortAscending from "./svg/sort-ascending.svg?raw";

export const ICONS = {
  ARTISTS: music,
  ALBUMS: disc,
  GENRES: music,
  PLAYLISTS: playlist,
  RADIO: radio,
  SEARCH: search,

  PLAY: playerPlayFilled,
  PLAY_OUTLINE: playerPlayEmpty,
  PAUSE: playerPause,
  PREVIOUS: playerSkipBack,
  NEXT: playerSkipForward,
  SHUFFLE: arrowsShuffle2,
  REPEAT: repeat,

  VOLUME_FULL: volumeFull,
  VOLUME_MEDIUM: volumeMedium,
  VOLUME_MUTE: volumeMute,
  VOLUME_OFF: volumeOff,

  HEART: heartEmpty,
  HEART_FILLED: heartFilled,

  SYNC: refresh,
  SETTINGS: settings,
  CLOSE: x,
  MENU: menu2,
  BACK: chevronLeft,
  BACK_COMPACT: chevronCompactLeft,
  CHEVRON_DOWN: chevronCompactDown,
  DRAG_HANDLE: gripHorizontal,
  REMOVE: trash,
  DEEZER: brandDeezer,
  SAVE: deviceFloppy,
  EDIT: filePencil,
  ADD: plus,
  ACCEPT: circleCheck,

  DOTS: dots,
  ADD_TO_PLAYLIST: plus,
  ALBUM_LINK: disc,
  ARTIST_LINK: music,

  SORT_DESC: sortDescending,
  SORT_ASC: sortAscending,
};

=== ./lib/workers/sync.worker.js ===
import { db } from "../db";
import md5 from "md5";

let apiUrl;

function decodeEntities(str) {
  if (!str) return "";
  if (typeof str !== "string") return String(str);
  return str
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#039;/g, "'")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">");
}

self.onmessage = async (e) => {
  const { type, payload } = e.data;

  if (type === "START_SYNC") {
    apiUrl = payload.url;
    await startSync();
  }
};

async function startSync() {
  try {
    self.postMessage({ type: "PROGRESS", status: "connecting" });

    const response = await fetch(apiUrl);

    if (!response.ok) {
      const errText = await response.text();
      throw new Error(
        `HTTP Error ${response.status}: ${errText.substring(0, 100)}`,
      );
    }

    self.postMessage({ type: "PROGRESS", status: "downloading" });

    const textData = await response.text();
    const trimmed = textData.trim();

    if (trimmed.length === 0) {
      throw new Error("Server returned empty response");
    }

    if (trimmed.charAt(0) !== "[" && trimmed.charAt(0) !== "{") {
      console.error(
        "CRITICAL: Server returned non-JSON data:",
        textData.substring(0, 500),
      );
      throw new Error(
        `Invalid JSON. Server says: ${textData.substring(0, 100)}...`,
      );
    }

    let rawData;
    try {
      rawData = JSON.parse(textData);
    } catch (e) {
      throw new Error("JSON Parse Error: " + e.message);
    }

    if (!Array.isArray(rawData)) {
      if (rawData.error) {
        throw new Error("API Error: " + rawData.error);
      }
      if (Object.keys(rawData).length === 0) {
        rawData = [];
      } else {
        throw new Error("Invalid response format: expected JSON array");
      }
    }

    self.postMessage({
      type: "PROGRESS",
      status: "parsing",
      count: rawData.length,
    });

    const tracks = rawData.map((item) => {
      const file = (item.file || "").normalize("NFC").trim();
      const title = decodeEntities(item.title || file.split("/").pop())
        .normalize("NFC")
        .trim();

      const rawArtist = Array.isArray(item.artist)
        ? item.artist.join(", ")
        : item.artist || "Unknown Artist";
      const artist = decodeEntities(rawArtist).normalize("NFC").trim();

      const album = decodeEntities(item.album || "Unknown Album")
        .normalize("NFC")
        .trim();

      const rawGenre = Array.isArray(item.genre)
        ? item.genre.join(", ")
        : item.genre || "Unknown";
      const genre = decodeEntities(rawGenre).normalize("NFC").trim();

      // Обработка Album Artist (несколько вариантов ключей)
      const rawAlbumArtist =
        item.album_artist || item.albumartist || item.AlbumArtist;
      const album_artist = rawAlbumArtist
        ? decodeEntities(rawAlbumArtist).normalize("NFC").trim()
        : null;

      // Генерация хеша для обложек на основе пути к папке
      let thumbHash = null;
      if (file) {
        try {
          const lastSlashIndex = file.lastIndexOf("/");
          const dirPath =
            lastSlashIndex === -1 ? "." : file.substring(0, lastSlashIndex);

          thumbHash = md5(dirPath);
        } catch (err) {
          console.warn("Failed to generate thumb hash for", file);
        }
      }

      let qualityBadge = null;
      if (item.encoded_at) {
        qualityBadge = item.encoded_at.replace(/,/g, " ").trim();
      }

      return {
        file,
        title,
        artist,
        album,
        genre,
        album_artist,

        time: parseFloat(item.time || 0),
        track: parseInt(item.tracknum || 0),
        disc: parseInt(item.disc || 1),
        year: parseInt(item.year || 0),

        encoded_at: item.encoded_at,
        last_modified: item.last_modified,

        thumbHash,
        qualityBadge,
      };
    });

    self.postMessage({
      type: "PROGRESS",
      status: "saving",
      count: tracks.length,
    });

    await db.clear();
    await db.bulkAdd(tracks);

    self.postMessage({ type: "DONE", count: tracks.length });
  } catch (e) {
    console.error(e);
    self.postMessage({ type: "ERROR", message: e.message });
  }
}

=== ./lib/mpd/library.js ===
import { get } from "svelte/store";
import { mpdClient } from "./client";
import { MpdParser } from "./parser";
import { CONFIG } from "../../config";
import {
  isSyncingLibrary,
  isLoadingPlaylists,
  playlists,
  isLoadingTracks,
  activePlaylistTracks,
  showToast,
  favorites,
} from "../store";
import { db } from "../db";
import SyncWorker from "../workers/sync.worker.js?worker";
import { generateUid } from "../utils";

const FAV_PLAYLIST = "Favorites";

let _favActionQueue = Promise.resolve();

const normFile = (path) => {
  if (!path) return "";
  try {
    let p = decodeURIComponent(path).normalize("NFC");
    if (p.startsWith("/")) p = p.slice(1);
    return p.trim().toLowerCase();
  } catch (e) {
    return String(path).toLowerCase();
  }
};

const cleanUrl = (url) => {
  if (!url) return "";
  return url
    .toLowerCase()
    .replace(/^https?:\/\//, "")
    .replace(/^www\./, "")
    .split("?")[0]
    .replace(/\/$/, "");
};

function getGradient(name) {
  if (name === "Favorites") {
    return `linear-gradient(135deg, hsl(348, 95%, 58%), hsl(348, 90%, 40%))`;
  }
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash % 360);
  return `linear-gradient(135deg, hsl(${hue}, 60%, 40%), hsl(${(hue + 40) % 360}, 60%, 30%))`;
}

export const LibraryActions = {
  async syncLibrary() {
    if (get(isSyncingLibrary)) return;
    isSyncingLibrary.set(true);

    const worker = new SyncWorker();
    worker.postMessage({
      type: "START_SYNC",
      payload: { url: `http://${CONFIG.MOODE_IP}/wave-api.php` },
    });

    worker.onmessage = (e) => {
      const { type, count } = e.data;
      if (type === "DONE") {
        showToast(`Library updated: ${count} tracks`, "success");
        isSyncingLibrary.set(false);
        worker.terminate();
      }
      if (type === "ERROR") {
        showToast("Sync Failed", "error");
        isSyncingLibrary.set(false);
        worker.terminate();
      }
    };
    worker.onerror = () => {
      isSyncingLibrary.set(false);
      worker.terminate();
    };
  },

  async loadPlaylists() {
    isLoadingPlaylists.set(true);
    try {
      const text = await mpdClient.send("listplaylists");
      const rawPlaylists = MpdParser.parsePlaylists(text);

      const enhanced = rawPlaylists.map((pl) => ({
        ...pl,
        color: getGradient(pl.name),
      }));

      playlists.set(enhanced);
    } catch (e) {
      console.error(e);
    } finally {
      isLoadingPlaylists.set(false);
    }
  },

  async openPlaylistDetails(playlistName) {
    if (!playlistName) return;
    isLoadingTracks.set(true);
    const safeName = playlistName.replace(/"/g, '\\"');
    try {
      const text = await mpdClient.send(`listplaylistinfo "${safeName}"`);
      const rawTracks = MpdParser.parseTracks(text);

      // Собираем пути файлов, чтобы найти их в DB
      const filesToLookup = rawTracks
        .map((t) => t.file)
        .filter((f) => f && !f.startsWith("http"));

      let cachedMap = new Map();
      if (filesToLookup.length > 0) {
        try {
          cachedMap = await db.getFilesMap(filesToLookup);
        } catch (dbErr) {
          console.warn("Failed to hydrate playlist from DB", dbErr);
        }
      }

      const enrichedTracks = rawTracks.map((track) => {
        const cached = cachedMap.get(track.file);
        if (cached) {
          return {
            ...track,
            // Дополняем данными из базы
            thumbHash: cached.thumbHash,
            qualityBadge: cached.qualityBadge,
            // Если в MPD нет title/artist, берем из базы (fallback)
            title: track.title || cached.title,
            artist: track.artist || cached.artist,
            album: track.album || cached.album,
            _uid: generateUid(),
          };
        }
        return {
          ...track,
          _uid: generateUid(),
        };
      });
      // --- HYDRATION END ---

      activePlaylistTracks.set(enrichedTracks);
    } catch (e) {
      console.error(e);
      showToast("Could not load playlist", "error");
    } finally {
      isLoadingTracks.set(false);
    }
  },

  async movePlaylistTrack(playlistName, fromPos, toPos) {
    const safeName = playlistName.replace(/"/g, '\\"');
    try {
      await mpdClient.send(`playlistmove "${safeName}" ${fromPos} ${toPos}`);
    } catch (e) {
      showToast("Move failed", "error");
    }
  },

  async removeFromPlaylist(playlistName, pos) {
    const safeName = playlistName.replace(/"/g, '\\"');
    try {
      await mpdClient.send(`playlistdelete "${safeName}" ${pos}`);
      showToast("Track removed", "success");
    } catch (e) {
      showToast("Delete failed", "error");
    }
  },

  async loadFavorites() {
    try {
      const text = await mpdClient.send(`listplaylistinfo "${FAV_PLAYLIST}"`);
      const tracks = MpdParser.parseTracks(text);

      const favSet = new Set();
      tracks.forEach((t) => {
        if (t.file) {
          favSet.add(t.file);
        }
      });

      favorites.set(favSet);
    } catch (e) {
      favorites.set(new Set());
    }
  },

  async toggleFavorite(track) {
    if (!track || !track.file) return;

    const rawFile = track.file;
    const safeFile = rawFile.replace(/"/g, '\\"');
    const isUrl = rawFile.startsWith("http");

    const currentFavs = get(favorites);
    let isFav = currentFavs.has(rawFile);

    if (!isFav && isUrl) {
      const targetClean = cleanUrl(rawFile);
      for (const f of currentFavs) {
        if (cleanUrl(f) === targetClean) {
          isFav = true;
          break;
        }
      }
    }

    favorites.update((s) => {
      const newSet = new Set(s);
      if (isFav) {
        newSet.delete(rawFile);
        if (isUrl) {
          const t = cleanUrl(rawFile);
          for (const f of newSet) if (cleanUrl(f) === t) newSet.delete(f);
        }
      } else {
        newSet.add(rawFile);
      }
      return newSet;
    });

    _favActionQueue = _favActionQueue.then(async () => {
      try {
        const text = await mpdClient.send(`listplaylistinfo "${FAV_PLAYLIST}"`);
        const tracks = MpdParser.parseTracks(text);

        let matchIndices = [];

        tracks.forEach((t, i) => {
          let match = false;
          if (t.file === rawFile) match = true;
          else if (isUrl && cleanUrl(t.file) === cleanUrl(rawFile))
            match = true;
          else if (
            isUrl &&
            (t.file.includes(rawFile) || rawFile.includes(t.file))
          )
            match = true;

          if (match) matchIndices.push(i);
        });

        if (isFav) {
          if (matchIndices.length > 0) {
            matchIndices.sort((a, b) => b - a);
            for (const idx of matchIndices) {
              await mpdClient.send(`playlistdelete "${FAV_PLAYLIST}" ${idx}`);
            }
            showToast("Removed from Favorites", "info");
          }
        } else {
          if (matchIndices.length > 0) {
            console.log("[Fav] Track already exists. Skipping.");
          } else {
            await mpdClient.send(`playlistadd "${FAV_PLAYLIST}" "${safeFile}"`);
            if (tracks.length > 0) {
              await mpdClient.send(
                `playlistmove "${FAV_PLAYLIST}" ${tracks.length} 0`,
              );
            }
            showToast("Added to Favorites", "success");
          }
        }
      } catch (e) {
        console.error("Fav action failed", e);
        showToast("Action failed", "error");
      } finally {
        await this.loadFavorites();
      }
    });
  },
};

=== ./lib/mpd/index.js ===
import { get } from "svelte/store";
import { mpdClient } from "./client";
import { PlayerActions, startStatusPoller } from "./player";
import { LibraryActions } from "./library";
import { currentSong, stations, selectedStationName, status } from "../store";

export function connect() {
  mpdClient.connect();
  startStatusPoller();
  LibraryActions.loadPlaylists();
  LibraryActions.loadFavorites();
}

export function runMpdRequest(cmd) {
  return mpdClient.send(cmd);
}

export const {
  togglePlay,
  toggleRandom,
  toggleRepeat,
  setVolume,
  seek,
  addToQueue,
  playNext,
  removeFromQueue,
  moveTrack,
  saveQueue,
  playAllTracks,
  addAllToQueue,
} = PlayerActions;

export const {
  syncLibrary,
  loadRadioStations,
  loadPlaylists,
  openPlaylistDetails,
  toggleFavorite,
  loadFavorites,
  removeFromPlaylist,
  movePlaylistTrack,
} = LibraryActions;

export function nav(cmd) {
  const song = get(currentSong);
  const stationList = get(stations);
  const selStation = get(selectedStationName);
  const isRadioMode = song.file && song.file.startsWith("http");

  if (
    isRadioMode &&
    stationList.length > 0 &&
    (cmd === "next" || cmd === "previous")
  ) {
    let currentIndex = stationList.findIndex((s) => s.name === selStation);
    if (currentIndex === -1) currentIndex = 0;

    let nextIndex;
    if (cmd === "next") {
      nextIndex = currentIndex + 1;
      if (nextIndex >= stationList.length) nextIndex = 0;
    } else {
      nextIndex = currentIndex - 1;
      if (nextIndex < 0) nextIndex = stationList.length - 1;
    }
    playStation(stationList[nextIndex]);
  } else {
    if (cmd === "next") PlayerActions.next();
    if (cmd === "previous") PlayerActions.previous();
  }
}

export function playStation(station) {
  if (!station) return;
  selectedStationName.set(station.name);
  const streamUrl =
    station[1] || station.station || station.file || station.url;
  if (!streamUrl) return;

  PlayerActions.playUri(streamUrl, {
    title: station.name,
    artist: station.genre || "Radio Stream",
    stationName: station.name,
  });
}

export function playTrackOptimistic(track) {
  if (!track) return;
  selectedStationName.set(null);
  PlayerActions.playUri(track.file, {
    title: track.title,
    artist: track.artist,
    album: track.album,
    stationName: null,
  });
}

export async function playPlaylistContext(playlistName, index = 0) {
  if (!playlistName) return;
  selectedStationName.set(null);
  const safeName = playlistName.replace(/"/g, '\\"');
  try {
    await mpdClient.send("stop");
    await mpdClient.send("clear");
    await mpdClient.send(`load "${safeName}"`);
    await mpdClient.send(`play ${index}`);
  } catch (e) {
    console.error("Failed to play playlist context", e);
  }
}

=== ./lib/mpd/player.js ===
import { get } from "svelte/store";
import { mpdClient } from "./client";
import { MpdParser } from "./parser";
import {
  status,
  currentSong,
  stations,
  showToast,
  queueVersion,
  queue,
  isQueueLocked,
} from "../store";
import { db } from "../db";
import { generateUid } from "../utils";

const POLLER_INTERVAL = 1000;
const TICKER_INTERVAL = 250;

let statusPoller = null;
let playbackTicker = null;
let lastTickTime = 0;
let timeDriftSpeed = 1.0;

let isInitialSync = true;
let forceHardSync = false;
let ignoreUpdatesUntil = 0;
let queueUnlockTimer = null;

function escapePath(str) {
  if (!str) return "";
  return String(str)
    .normalize("NFC")
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"');
}

export function startStatusPoller() {
  stopStatusPoller();
  isInitialSync = true;
  forceHardSync = false;
  ignoreUpdatesUntil = 0;
  isQueueLocked.set(false);

  refreshStatus();
  statusPoller = setInterval(() => {
    if (mpdClient.isConnected && !mpdClient.isProcessing) {
      refreshStatus();
    }
  }, POLLER_INTERVAL);
}

export function stopStatusPoller() {
  if (statusPoller) {
    clearInterval(statusPoller);
    statusPoller = null;
  }
  stopTicker();
}

async function refreshStatus() {
  try {
    const statusText = await mpdClient.send("status");
    const songText = await mpdClient.send("currentsong");

    const newStatus = MpdParser.parseStatus(statusText);
    const newSong = MpdParser.parseCurrentSong(songText);

    updateStores(newStatus, newSong);

    const oldVer = get(queueVersion);
    const locked = get(isQueueLocked);

    if (locked) return;

    if (
      (newStatus.playlistLength > 0 && newStatus.playlistVersion !== oldVer) ||
      (newStatus.playlistLength > 0 && get(queue).length === 0)
    ) {
      syncQueue(newStatus.playlistVersion);
    }
  } catch (e) {
    // Silent fail on connection drops
  }
}

async function syncQueue(newVersion) {
  if (get(isQueueLocked)) return;

  try {
    const text = await mpdClient.send("playlistinfo");
    if (get(isQueueLocked)) return;

    const rawTracks = MpdParser.parseTracks(text);

    const filesToLookup = rawTracks
      .map((t) => t.file)
      .filter((f) => f && !f.startsWith("http"));

    let cachedMap = new Map();
    if (filesToLookup.length > 0) {
      try {
        cachedMap = await db.getFilesMap(filesToLookup);
      } catch (dbErr) {
        console.warn("Failed to hydrate queue from DB", dbErr);
      }
    }

    const tracks = rawTracks.map((t) => {
      const lookupKey = (t.file || "").normalize("NFC");
      const cached = cachedMap.get(lookupKey);

      if (cached) {
        return {
          ...t,
          thumbHash: cached.thumbHash,
          qualityBadge: cached.qualityBadge,
          title: t.title || cached.title,
          artist: t.artist || cached.artist,
          album: t.album || cached.album,
          _uid: String(t.id || t.pos + t.file),
        };
      }
      return {
        ...t,
        _uid: String(t.id || t.pos + t.file),
      };
    });

    queue.set(tracks);
    queueVersion.set(newVersion);
  } catch (e) {
    console.error("Queue sync error", e);
  }
}

function updateStores(serverStatus, serverSong) {
  const oldSong = get(currentSong);
  const allStations = get(stations);

  const isRadio = serverSong.file && serverSong.file.startsWith("http");
  if (isRadio) {
    const clean = (str) =>
      (str || "")
        .toString()
        .toLowerCase()
        .replace(/[^a-z0-9]/g, "");
    const targetUrl = clean(serverSong.file);
    const targetTitle = clean(serverSong.title);

    const found = allStations.find((s) => {
      const sUrl = clean(
        s.station || s.file || s.url || (Array.isArray(s) ? s[1] : ""),
      );
      const sName = clean(s.name || (Array.isArray(s) ? s[0] : ""));
      return (
        (sUrl && targetUrl.includes(sUrl)) ||
        (sName && targetTitle.includes(sName))
      );
    });

    if (found) {
      serverSong.stationName = found.name || found[0];
    } else if (oldSong.stationName && oldSong.file === serverSong.file) {
      serverSong.stationName = oldSong.stationName;
    }
  }

  currentSong.set(serverSong);

  status.update((localStatus) => {
    const isPlaying = serverStatus.state === "play";
    const now = performance.now();

    if (serverStatus.state === "pause" || localStatus.state === "pause") {
      manageTicker(false);
      return now < ignoreUpdatesUntil ? localStatus : serverStatus;
    }

    if (serverSong.file !== oldSong.file || isInitialSync) {
      isInitialSync = false;
      forceHardSync = false;
      timeDriftSpeed = 1.0;
      if (isRadio) serverStatus.elapsed = 0;
      manageTicker(isPlaying && !isRadio);
      return serverStatus;
    }

    if (now < ignoreUpdatesUntil) return localStatus;

    if (forceHardSync) {
      forceHardSync = false;
      timeDriftSpeed = 1.0;
      manageTicker(isPlaying && !isRadio);
      return serverStatus;
    }

    if (isPlaying && !isRadio) {
      const diff = serverStatus.elapsed - localStatus.elapsed;
      if (Math.abs(diff) > 2.0) {
        timeDriftSpeed = 1.0;
        return serverStatus;
      }
      if (Math.abs(diff) < 0.05) {
        timeDriftSpeed = 1.0;
      } else {
        const timeToCorrect = 1.5;
        let correction = diff / timeToCorrect;
        timeDriftSpeed = Math.max(0.5, Math.min(1.5, 1.0 + correction));
      }
      return { ...serverStatus, elapsed: localStatus.elapsed };
    }

    manageTicker(false);
    return serverStatus;
  });
}

function manageTicker(shouldRun) {
  if (shouldRun) startTicker();
  else stopTicker();
}

function startTicker() {
  if (playbackTicker || isInitialSync) return;
  lastTickTime = performance.now();
  playbackTicker = setInterval(() => {
    const now = performance.now();
    let deltaTime = (now - lastTickTime) / 1000;
    if (deltaTime > 2.0) deltaTime = 0;
    lastTickTime = now;

    status.update((s) => {
      if (s.state !== "play") return s;
      let newElapsed = s.elapsed + deltaTime * timeDriftSpeed;
      if (s.duration > 0 && newElapsed > s.duration) newElapsed = s.duration;
      return { ...s, elapsed: newElapsed };
    });
  }, TICKER_INTERVAL);
}

function stopTicker() {
  if (playbackTicker) {
    clearInterval(playbackTicker);
    playbackTicker = null;
  }
  timeDriftSpeed = 1.0;
  lastTickTime = 0;
}

async function sendTracksInChunks(tracks, playAfter = false) {
  if (!tracks || tracks.length === 0) return;

  isQueueLocked.set(true);
  forceHardSync = true;

  const CHUNK_SIZE = 5;

  try {
    for (let i = 0; i < tracks.length; i += CHUNK_SIZE) {
      const chunk = tracks.slice(i, i + CHUNK_SIZE);
      const commands = ["command_list_begin"];

      chunk.forEach((t) => {
        commands.push(`add "${escapePath(t.file)}"`);
      });
      commands.push("command_list_end");

      await mpdClient.send(commands.join("\n"));
    }

    if (playAfter) {
      await mpdClient.send("play 0");
      showToast(`Playing ${tracks.length} tracks`, "success");
    } else {
      showToast(`Added ${tracks.length} tracks`, "success");
    }
  } catch (e) {
    console.error("[Player] Bulk Action Failed:", e);
    showToast("Error adding tracks", "error");
  } finally {
    setTimeout(() => {
      isQueueLocked.set(false);
      refreshStatus();
    }, 1500);
  }
}

export const PlayerActions = {
  async togglePlay() {
    const s = get(status);
    const isPlaying = s.state === "play";
    ignoreUpdatesUntil = performance.now() + 800;
    status.update((curr) => {
      const newState = isPlaying ? "pause" : "play";
      if (newState === "play") startTicker();
      else stopTicker();
      return { ...curr, state: newState };
    });
    await mpdClient.send(isPlaying ? "pause 1" : "play");
    setTimeout(refreshStatus, 900);
  },

  async next() {
    forceHardSync = true;
    ignoreUpdatesUntil = 0;
    await mpdClient.send("next");
    refreshStatus();
  },

  async previous() {
    forceHardSync = true;
    ignoreUpdatesUntil = 0;
    status.update((s) => ({ ...s, elapsed: 0 }));
    await mpdClient.send("previous");
    refreshStatus();
  },

  async setVolume(val) {
    status.update((s) => ({ ...s, volume: val }));
    await mpdClient.send(`setvol ${val}`);
  },

  async seek(seconds) {
    forceHardSync = true;
    ignoreUpdatesUntil = performance.now() + 500;
    status.update((s) => ({ ...s, elapsed: seconds }));
    await mpdClient.send(`seekcur ${seconds}`);
    setTimeout(refreshStatus, 600);
  },

  async toggleRandom() {
    const s = get(status);
    const newVal = !s.random;
    status.update((curr) => ({ ...curr, random: newVal }));
    await mpdClient.send(`random ${newVal ? 1 : 0}`);
  },

  async toggleRepeat() {
    const s = get(status);
    const newVal = !s.repeat;
    status.update((curr) => ({ ...curr, repeat: newVal }));
    await mpdClient.send(`repeat ${newVal ? 1 : 0}`);
  },

  async playUri(uri, meta = {}) {
    isQueueLocked.set(true);
    const safeUri = escapePath(uri);
    forceHardSync = true;

    status.update((s) => ({ ...s, state: "play", elapsed: 0 }));
    currentSong.set({
      title: meta.title || uri.split("/").pop(),
      artist: meta.artist || "",
      file: uri,
    });
    startTicker();

    try {
      await mpdClient.send("stop");
      await mpdClient.send("clear");
      await mpdClient.send(`add "${safeUri}"`);
      await mpdClient.send("play");
    } catch (e) {
      console.error("Play error", e);
      showToast("Failed to play", "error");
    }

    setTimeout(() => {
      isQueueLocked.set(false);
      refreshStatus();
    }, 1200);
  },

  async addToQueue(uri) {
    try {
      await mpdClient.send(`add "${escapePath(uri)}"`);
      showToast("Added to queue", "success");
    } catch (e) {
      console.error("Add queue error", e);
      showToast("Failed to add", "error");
    }
  },

  async playNext(uri) {
    isQueueLocked.set(true);
    const safeUri = escapePath(uri);
    try {
      const songData = await mpdClient.send("currentsong");
      const currentPos = parseInt(MpdParser.parseKeyValue(songData).pos || -1);

      if (currentPos === -1) {
        isQueueLocked.set(false);
        await this.playUri(uri);
      } else {
        const res = await mpdClient.send(`addid "${safeUri}"`);
        const newId = parseInt(MpdParser.parseKeyValue(res).id);

        if (!isNaN(newId)) {
          await mpdClient.send(`moveid ${newId} ${currentPos + 1}`);
          showToast("Will play next", "success");
        }
        setTimeout(() => isQueueLocked.set(false), 1000);
      }
    } catch (e) {
      console.error("Play Next error", e);
      showToast("Failed to set next", "error");
      isQueueLocked.set(false);
    }
  },

  async removeFromQueue(pos) {
    isQueueLocked.set(true);
    if (queueUnlockTimer) clearTimeout(queueUnlockTimer);

    try {
      queue.update((q) => {
        const copy = [...q];
        copy.splice(pos, 1);
        return copy;
      });
      await mpdClient.send(`delete ${pos}`);
    } catch (e) {
      showToast("Failed to remove", "error");
      isQueueLocked.set(false);
      return;
    }
    queueUnlockTimer = setTimeout(() => {
      isQueueLocked.set(false);
    }, 1000);
  },

  async moveTrack(fromPos, toPos) {
    if (fromPos === toPos) return;

    isQueueLocked.set(true);
    if (queueUnlockTimer) clearTimeout(queueUnlockTimer);

    try {
      await mpdClient.send(`move ${fromPos} ${toPos}`);
    } catch (e) {
      console.error("Move failed", e);
      showToast("Move failed", "error");
      isQueueLocked.set(false);
      refreshStatus();
      return;
    }

    queueUnlockTimer = setTimeout(() => {
      isQueueLocked.set(false);
      refreshStatus();
    }, 2000);
  },

  async playAllTracks(tracks) {
    if (!tracks || tracks.length === 0) return;
    try {
      await mpdClient.send("stop");
      await mpdClient.send("clear");
      await sendTracksInChunks(tracks, true);
    } catch (e) {
      console.error(e);
    }
  },

  async addAllToQueue(tracks) {
    if (!tracks || tracks.length === 0) return;
    await sendTracksInChunks(tracks, false);
  },

  async saveQueue(name) {
    if (!name) return;
    const safeName = name.replace(/"/g, '\\"');
    try {
      await mpdClient.send(`save "${safeName}"`);
      showToast(`Playlist "${name}" saved`, "success");
    } catch (e) {
      if (e.message.includes("exist")) {
        if (confirm(`Playlist "${name}" exists. Overwrite?`)) {
          try {
            await mpdClient.send(`rm "${safeName}"`);
            await mpdClient.send(`save "${safeName}"`);
            showToast(`Playlist "${name}" overwritten`, "success");
          } catch (err) {
            showToast("Failed to overwrite", "error");
          }
        }
      } else {
        console.error(e);
      }
    }
  },
};

=== ./lib/mpd/client.js ===
import { CONFIG } from "../../config";
import { connectionStatus, showToast } from "../store";

class MpdClient {
  constructor() {
    this.socket = null;
    this.queue = [];
    this.isProcessing = false;
    this.reconnectTimer = null;
    this.watchdogTimer = null;
    this._buffer = "";
  }

  get isConnected() {
    return this.socket && this.socket.readyState === WebSocket.OPEN;
  }

  connect() {
    if (
      this.socket &&
      (this.socket.readyState === WebSocket.CONNECTING ||
        this.socket.readyState === WebSocket.OPEN)
    ) {
      return;
    }

    if (this.reconnectTimer) clearTimeout(this.reconnectTimer);

    let host = CONFIG.MOODE_IP || window.location.hostname;
    host = host
      .replace(/^https?:\/\//, "")
      .split(":")[0]
      .split("/")[0];
    const port = CONFIG.WS_PORT || "8080";
    const wsUrl = `ws://${host}:${port}`;

    console.log("[MPD] Connecting to:", wsUrl);

    try {
      this.socket = new WebSocket(wsUrl, ["binary"]);
    } catch (e) {
      console.error("[MPD] Connection Error:", e);
      this.reconnectTimer = setTimeout(() => this.connect(), 5000);
      return;
    }

    this.socket.onopen = () => {
      console.log("[MPD] Connected");
      connectionStatus.set("Connected");
      showToast("Connected to Moode", "success");
      this._processQueue();
    };

    this.socket.onmessage = (event) => this._handleMessage(event);

    this.socket.onclose = (e) => {
      console.warn("[MPD] Socket closed", e.code, e.reason);
      connectionStatus.set("Disconnected");
      this._cleanup();
      this.reconnectTimer = setTimeout(() => this.connect(), 3000);
    };

    this.socket.onerror = (err) => {
      console.error("[MPD] Socket error", err);
    };
  }

  send(cmd) {
    return new Promise((resolve, reject) => {
      this.queue.push({ cmd, resolve, reject });
      this._processQueue();
    });
  }

  _cleanup() {
    this.isProcessing = false;
    this._buffer = "";
    if (this.watchdogTimer) clearTimeout(this.watchdogTimer);

    while (this.queue.length > 0) {
      const { reject } = this.queue.shift();
      reject(new Error("Connection lost"));
    }
  }

  async _processQueue() {
    if (this.isProcessing || this.queue.length === 0 || !this.isConnected)
      return;

    this.isProcessing = true;
    const { cmd } = this.queue[0];

    // Таймаут 20с для больших запросов (например, playlistinfo)
    if (this.watchdogTimer) clearTimeout(this.watchdogTimer);
    this.watchdogTimer = setTimeout(() => {
      console.error("[MPD] Watchdog timeout");
      if (this.socket) this.socket.close();
    }, 20000);

    try {
      const payload = cmd.endsWith("\n") ? cmd : cmd + "\n";
      this.socket.send(new TextEncoder().encode(payload));
    } catch (e) {
      console.error("[MPD] Send error", e);
      this._cleanup();
    }
  }

  async _handleMessage(event) {
    let text = event.data;
    if (text instanceof Blob) {
      text = await text.text();
    }

    if (this.watchdogTimer) {
      clearTimeout(this.watchdogTimer);
      this.watchdogTimer = null;
    }

    // Всегда добавляем в буфер
    this._buffer += text;

    const isSuccess =
      this._buffer.endsWith("\nOK\n") || this._buffer === "OK\n";
    const isError = this._buffer.startsWith("ACK");

    if (isSuccess || isError) {
      const fullResponse = this._buffer;
      this._buffer = ""; // Очистка буфера

      const currentRequest = this.queue.shift();
      this.isProcessing = false;

      if (currentRequest) {
        if (isError) {
          console.error(`[MPD] Error: ${fullResponse.trim()}`);
          currentRequest.reject(new Error(fullResponse.trim()));
        } else {
          const cleanResult = fullResponse
            .replace(/\nOK\n$/, "")
            .replace(/^OK\n$/, "");
          currentRequest.resolve(cleanResult);
        }
      }

      this._processQueue();
    } else {
      // Если ответ не завершен, перезапускаем таймер, чтобы не разорвать соединение
      if (!this.queue.length) return;

      this.watchdogTimer = setTimeout(() => {
        console.error("[MPD] Watchdog timeout receiving large data");
        if (this.socket) this.socket.close();
      }, 20000);
    }
  }
}

export const mpdClient = new MpdClient();

=== ./lib/mpd/parser.js ===
/**
 * Robust MPD Parser.
 * Handles parsing iteratively to avoid memory spikes on large libraries.
 */
export const MpdParser = {
  parseKeyValue(text) {
    const result = {};
    if (!text) return result;

    const lines = text.split("\n");
    for (const line of lines) {
      const idx = line.indexOf(": ");
      if (idx === -1) continue;
      // ВАЖНО: приводим ключ к нижнему регистру
      const key = line.substring(0, idx).toLowerCase();
      const val = line.substring(idx + 2);
      result[key] = val;
    }
    return result;
  },

  parseStatus(text) {
    const data = this.parseKeyValue(text);
    let format = "";
    if (data.audio) {
      const parts = data.audio.split(":");
      if (parts[1]) {
        format = `${parts[1]}-bit`;
      }
    }
    return {
      state: data.state || "stop",
      volume: parseInt(data.volume) || 0,
      elapsed: parseFloat(data.elapsed) || 0,
      duration: parseFloat(data.duration) || 0,
      random: data.random === "1",
      repeat: data.repeat === "1",
      songId: parseInt(data.songid) || -1,
      playlistLength: parseInt(data.playlistlength) || 0,
      bitrate: parseInt(data.bitrate) || 0,
      format: format,
      playlistVersion: parseInt(data.playlist) || 0,
    };
  },

  parseCurrentSong(text) {
    const data = this.parseKeyValue(text);
    return this._normalizeTrack(data);
  },

  parsePlaylists(text) {
    const lines = text.split("\n");
    const items = [];
    let current = null;

    for (const line of lines) {
      if (line.startsWith("playlist: ")) {
        if (current) items.push(current);
        current = { playlist: line.substring(10) };
      } else if (line.startsWith("Last-Modified: ") && current) {
        current["last-modified"] = line.substring(15);
      }
    }
    if (current) items.push(current);
    return items.map((i) => ({
      name: i.playlist,
      lastModified: i["last-modified"],
    }));
  },

  /**
   * STREAMING-LIKE PARSER FOR TRACKS
   */
  parseTracks(rawText) {
    const tracks = [];
    let currentTrack = null;

    let start = 0;
    let end = rawText.indexOf("\n", start);

    while (end !== -1) {
      const line = rawText.substring(start, end);
      const sepIndex = line.indexOf(": ");

      if (sepIndex !== -1) {
        // ВАЖНО: Lowercase key
        const key = line.substring(0, sepIndex).toLowerCase();
        const value = line.substring(sepIndex + 2);

        if (key === "file") {
          if (currentTrack) {
            tracks.push(this._normalizeTrack(currentTrack));
          }
          currentTrack = { file: value };
        } else if (currentTrack) {
          currentTrack[key] = value;
        }
      }

      start = end + 1;
      end = rawText.indexOf("\n", start);
    }

    if (currentTrack) {
      tracks.push(this._normalizeTrack(currentTrack));
    }

    return tracks;
  },

  _normalizeTrack(raw) {
    // raw ключи уже lowercase, если пришли через parseKeyValue,
    // но parseTracks заполняет их как есть, поэтому проверяем оба варианта
    const file = raw.file || raw.File || "";
    const title =
      raw.Title ||
      raw.title ||
      raw.Name ||
      raw.name ||
      file.split("/").pop() ||
      "Unknown";

    return {
      file: file,
      title: title,
      artist: raw.Artist || raw.artist || "Unknown Artist",
      album: raw.Album || raw.album || "Unknown Album",
      genre: raw.Genre || raw.genre || "Unknown",
      time: parseFloat(raw.Time || raw.time || 0),
      track: raw.Track || raw.track || "",
      id: raw.Id || raw.id,
      stationName: raw.name || raw.Name || null,
    };
  },
};

=== ./lib/actions.js ===
export function longpress(node, duration = 2000) {
  let timer;

  const handleStart = (e) => {
    // Игнорируем правый клик
    if (e.type === "mousedown" && e.button !== 0) return;

    timer = setTimeout(() => {
      node.dispatchEvent(
        new CustomEvent("longpress", {
          detail: { originalEvent: e },
        }),
      );
    }, duration);
  };

  const handleEnd = () => {
    clearTimeout(timer);
  };

  node.addEventListener("mousedown", handleStart);
  node.addEventListener("touchstart", handleStart, { passive: true });

  node.addEventListener("mouseup", handleEnd);
  node.addEventListener("mouseleave", handleEnd);
  node.addEventListener("touchend", handleEnd);
  node.addEventListener("touchcancel", handleEnd);
  node.addEventListener("touchmove", handleEnd);

  return {
    destroy() {
      node.removeEventListener("mousedown", handleStart);
      node.removeEventListener("touchstart", handleStart);
      node.removeEventListener("mouseup", handleEnd);
      node.removeEventListener("mouseleave", handleEnd);
      node.removeEventListener("touchend", handleEnd);
      node.removeEventListener("touchcancel", handleEnd);
      node.removeEventListener("touchmove", handleEnd);
    },
  };
}

=== ./lib/theme.js ===
export const THEME = {
  COLORS: {
    PRIMARY: "#fa2d48", // Moode Red
    BACKGROUND: "#121212",
    SURFACE: "#1a1a1a",
    SURFACE_LIGHT: "#2a2a2a",
    TEXT_MAIN: "#ffffff",
    TEXT_DIMMED: "#888888",
    TEXT_MUTED: "#444444",
    BORDER: "rgba(255, 255, 255, 0.1)",
    SKELETON: "rgba(255, 255, 255, 0.1)",
  },
  SPACING: {
    MINI_PLAYER_HEIGHT: "90px",
    TOP_BAR_HEIGHT: "64px",
    VIEW_PADDING: "32px",
    VIEW_PADDING_MOBILE: "16px",
  },
  ANIMATION: {
    DURATION_FAST: "200ms",
    DURATION_NORMAL: "300ms",
  },
};

=== ./lib/utils.js ===
export function getStationImageUrl(station) {
  if (!station || !station.image) return null;

  if (station.image.startsWith("http")) {
    return station.image;
  }

  let filename = "";
  if (station.image === "local") {
    filename = `${station.name}.jpg`;
  } else {
    filename = station.image;
  }

  const safeFilename = encodeURIComponent(filename);
  return `/imagesw/radio-logos/thumbs/${safeFilename}`;
}

export function getCoverUrl(song) {
  if (!song || !song.file) return null;

  if (!song.file.startsWith("http")) {
    return `/coverart.php?u=${encodeURIComponent(song.file)}`;
  }

  return null;
}

export function generateUid() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

=== ./lib/constants.js ===
import { CONFIG } from "../config";

export const DATABASE = {
  NAME: "MoodePlayerDB",
  STORE_NAME: "music",
  VERSION: 3,
};

export const API_ENDPOINTS = {
  SYNC: `/wave-api.php`,
  STATIONS: (isDev) => `/wave-api.php?action=stations`,
  COVER_ART: (file) => `/coverart.php?u=${encodeURIComponent(file)}`,
  RADIO_LOGOS: (filename) => `/imagesw/radio-logos/thumbs/${filename}`,
};

export const PLAYER_CONFIG = {
  POLLER_INTERVAL: 1000,
  TICKER_INTERVAL: 250,
  UI_LOCK_SHORT: 500,
  UI_LOCK_LONG: 800,
  UI_LOCK_SYNC: 1000,
  RECONNECT_DELAY: 3000,
  WATCHDOG_TIMEOUT: 5000,
};

export const FAVORITES_PLAYLIST = "Favorites";

=== ./lib/store.js ===
import { writable, derived, get } from "svelte/store";
import { CONFIG } from "../config";
import { getStationImageUrl } from "./utils";
import md5 from "md5";

export const connectionStatus = writable("Disconnected");

export const toastMessage = writable(null);
let toastTimer;

export function showToast(msg, type = "info") {
  toastMessage.set({ text: msg, type });
  if (toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    toastMessage.set(null);
  }, 3000);
}

export const status = writable({
  state: "stop",
  volume: 50,
  elapsed: 0,
  duration: 0,
  random: false,
  repeat: false,
  bitrate: 0,
  format: "",
});

export const currentSong = writable({
  title: "Not Playing",
  artist: "",
  album: "",
  file: "",
  stationName: null,
});

// UI
export const isFullPlayerOpen = writable(false);
export const isLoadingRadio = writable(false);
export const isLoadingPlaylists = writable(false);
export const isLoadingTracks = writable(false);
export const activeMenuTab = writable("library");
export const selectedStationName = writable(null);
export const isSyncingLibrary = writable(false);

// --- SIDEBAR PERSISTENCE START ---
const storedSidebar = localStorage.getItem("sidebarCollapsed") === "true";
export const isSidebarCollapsed = writable(storedSidebar);

// Подписываемся на изменения, чтобы сохранять в localStorage
isSidebarCollapsed.subscribe((val) => {
  if (typeof localStorage !== "undefined") {
    localStorage.setItem("sidebarCollapsed", String(val));
  }
});
// --- SIDEBAR PERSISTENCE END ---

// Library
export const stations = writable([]);
export const playlists = writable([]);
export const activePlaylistTracks = writable([]);
export const activePlaylistName = writable(null);
export const favorites = writable(new Set());
export const isQueueLocked = writable(false);

// Navigation
export const navigationStack = writable([{ view: "root" }]);
export const queue = writable([]);
export const queueVersion = writable(0);
export const searchQuery = writable("");

// Scroll
export const scrollPositions = writable({});
export function saveScrollPosition(key, pos) {
  scrollPositions.update((s) => ({ ...s, [key]: pos }));
}
export function getScrollPosition(key) {
  return get(scrollPositions)[key] || 0;
}

export const contextMenu = writable({
  isOpen: false,
  track: null,
  context: { type: "general", playlistName: null, index: null },
  x: 0,
  y: 0,
  triggerRect: null,
});

export const playlistSelector = writable({
  isOpen: false,
  track: null,
});

function vibrate() {
  if (typeof navigator !== "undefined" && navigator.vibrate) {
    try {
      navigator.vibrate(70);
    } catch (e) {
      // ignore
    }
  }
}

export function openContextMenu(e, track, contextData = {}) {
  if (!track) return;
  vibrate();

  let clientX = 0;
  let clientY = 0;
  let rect = null;

  let el = e.currentTarget;
  if (!el && e.target && e.target.closest) {
    el = e.target.closest("button") || e.target;
  }

  if (el && el.getBoundingClientRect) {
    rect = el.getBoundingClientRect();
  }

  const evt = e.detail?.originalEvent || e;
  if (evt.touches && evt.touches.length > 0) {
    clientX = evt.touches[0].clientX;
    clientY = evt.touches[0].clientY;
  } else if (evt.clientX) {
    clientX = evt.clientX;
    clientY = evt.clientY;
  }

  const ctx = {
    type: "general",
    playlistName: null,
    index: null,
    ...contextData,
  };

  contextMenu.set({
    isOpen: true,
    track,
    context: ctx,
    x: clientX,
    y: clientY,
    triggerRect: rect,
  });
}

export function closeContextMenu() {
  contextMenu.set({
    isOpen: false,
    track: null,
    context: {},
    x: 0,
    y: 0,
    triggerRect: null,
  });
}

export function openPlaylistSelector(track) {
  closeContextMenu();
  playlistSelector.set({ isOpen: true, track });
}

export function closePlaylistSelector() {
  playlistSelector.set({ isOpen: false, track: null });
}

// Routing
let pendingRouteData = null;
let onNavigateCallback = null;

export function setNavigationCallback(fn) {
  onNavigateCallback = fn;
}

export function navigateTo(view, data = null) {
  if (data) pendingRouteData = data;

  if (onNavigateCallback) {
    onNavigateCallback(view, data);
  } else {
    console.warn("Router callback not set!");
  }
}

export function consumeRouteData() {
  const d = pendingRouteData;
  pendingRouteData = null;
  return d;
}

export function navigateBack() {
  window.history.back();
}

export function handleBrowserBack() {
  // Placeholder
}

// FULL SIZE (for player)
export function getTrackCoverUrl(
  track,
  stationList = [],
  selectedRadioName = null,
) {
  if (!track || !track.file) return "/images/default_cover.png";

  if (isRadioTrack(track.file) || track.genre === "Radio") {
    if (track.image) {
      return getStationImageUrl(track);
    }
    return (
      resolveRadioImage(track, stationList, selectedRadioName) ||
      "/images/radio_placeholder.png"
    );
  }

  let cleanPath = track.file.startsWith("/") ? track.file.slice(1) : track.file;
  return `/coverart.php/${encodeURI(cleanPath)}`;
}

export function getTrackThumbUrl(
  track,
  size = "sm",
  stationList = [],
  selectedRadioName = null,
) {
  // Handle Radio
  if (
    !track ||
    (track.file &&
      (isRadioTrack(track.file) ||
        track.genre === "Radio" ||
        Array.isArray(track)))
  ) {
    if (track && track.image) {
      return getStationImageUrl(track);
    }
    return (
      resolveRadioImage(track, stationList, selectedRadioName) ||
      "/images/radio_icon.png"
    );
  }

  if (!track.file) return "/images/default_icon.png";

  // New Logic: Use thumbHash if available
  if (track.thumbHash) {
    const suffix = size === "md" ? "" : "_sm";
    return `/imagesw/thmcache/${track.thumbHash}${suffix}.jpg`;
  }

  // Fallback for legacy DB or uncached items
  try {
    const lastSlashIndex = track.file.lastIndexOf("/");
    const dirPath =
      lastSlashIndex === -1 ? "." : track.file.substring(0, lastSlashIndex);
    const hash = md5(dirPath);
    const suffix = size === "md" ? "" : "_sm";
    return `/imagesw/thmcache/${hash}${suffix}.jpg`;
  } catch (e) {
    let cleanPath = track.file.startsWith("/")
      ? track.file.slice(1)
      : track.file;
    return `/coverart.php/${encodeURI(cleanPath)}`;
  }
}

function isRadioTrack(file) {
  if (!file) return false;
  return (
    file.startsWith("http") || file.includes("://") || file.includes("RADIO")
  );
}

function resolveRadioImage(track, stationList, selectedRadioName) {
  const normalize = (str) =>
    (str || "")
      .toString()
      .toLowerCase()
      .replace(/[^a-z0-9]/g, "");

  const targetTitle = normalize(track?.title);
  const targetStationName = normalize(track?.stationName);
  const targetSelected = normalize(selectedRadioName);

  if (stationList && stationList.length > 0) {
    const found = stationList.find((s) => {
      const sName = normalize(s.name);
      if (!sName) return false;
      return (
        sName === targetStationName ||
        sName === targetSelected ||
        (targetTitle && sName === targetTitle) ||
        (targetTitle && targetTitle.includes(sName) && sName.length > 3)
      );
    });
    if (found) return getStationImageUrl(found);
  }

  const fallbackName = track?.stationName || selectedRadioName;
  if (fallbackName) {
    return getStationImageUrl({ name: fallbackName, image: "local" });
  }
  return null;
}

export const currentCover = derived(
  [currentSong, stations, selectedStationName],
  ([$song, $stations, $selectedName]) => {
    return getTrackCoverUrl($song, $stations, $selectedName);
  },
);

export const currentArtistImage = derived(currentSong, ($song) => {
  if (!$song || !$song.file) return null;
  if ($song.file.startsWith("http")) return null;
  return `/coverart.php/${encodeURI($song.file)}`;
});

export const coverUrl = currentCover;

=== ./sw.js ===
const CACHE_NAME = "covers-v1";

// кешируем обложки
const ASSET_REGEX = /\/coverart\.php|\/imagesw\//;

self.addEventListener("install", (event) => {
  self.skipWaiting(); // Активируем сразу после загрузки
});

self.addEventListener("activate", (event) => {
  // Очистка старых кэшей, если имя изменится
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cache) => {
            if (cache !== CACHE_NAME) {
              return caches.delete(cache);
            }
          }),
        );
      })
      .then(() => self.clients.claim()), // Немедленно берем контроль над страницей
  );
});

self.addEventListener("fetch", (event) => {
  const request = event.request;
  const url = new URL(request.url);

  // Проверяем, GET запрос ли это и соответствует ли нашим путям картинок
  if (request.method !== "GET" || !ASSET_REGEX.test(url.pathname)) {
    return;
  }

  event.respondWith(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.match(request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        // 2. Если нет в кэше — идем в сеть
        return fetch(request)
          .then((networkResponse) => {
            if (
              !networkResponse ||
              networkResponse.status !== 200 ||
              networkResponse.type === "error"
            ) {
              return networkResponse;
            }

            cache.put(request, networkResponse.clone());

            return networkResponse;
          })
          .catch(() => {
            // return caches.match('/images/default_icon.png');
          });
      });
    }),
  );
});

=== ./components/ImageLoader.svelte ===
<script>
  import { createEventDispatcher } from "svelte";
  import { fade } from "svelte/transition";
  import Skeleton from "./Skeleton.svelte";

  export let src;
  export let alt = "";
  export let radius = "0px";

  const dispatch = createEventDispatcher();
  let status = "loading";

  // reset on src change
  $: if (src) status = "loading";
  else status = "error";

  function onLoad() {
    status = "loaded";
  }
  function onError(e) {
    dispatch("error", e);
    status = "error";
  }
</script>

<div class="loader" style="border-radius: {radius}">
  {#if status === "loading"}
    <div class="skel" out:fade={{ duration: 200 }}>
      <Skeleton width="100%" height="100%" {radius} />
    </div>
  {/if}

  {#if src && status !== "error"}
    <img
      {src}
      {alt}
      loading="lazy"
      on:load={onLoad}
      on:error={onError}
      class:vis={status === "loaded"}
      style="border-radius: {radius}"
    />
  {/if}

  {#if status === "error"}
    <slot name="fallback" />
  {/if}
</div>

<style>
  .loader {
    width: 100%;
    height: 100%;
    position: relative;
  }
  .skel {
    position: absolute;
    inset: 0;
    z-index: 2;
  }
  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    opacity: 0;
    transition: opacity 0.3s ease-in;
    position: absolute;
    inset: 0;
    z-index: 1;
  }
  img.vis {
    opacity: 1;
  }
</style>

=== ./components/MainScreen.svelte ===
<script>
  import { onMount } from "svelte";
  import { fly } from "svelte/transition";
  import { ICONS } from "../lib/icons";
  import {
    activeMenuTab,
    navigationStack,
    navigateBack,
    handleBrowserBack,
    isFullPlayerOpen,
    toastMessage,
  } from "../lib/store";

  import LibraryView from "./views/LibraryView.svelte";
  import RadioView from "./views/RadioView.svelte";
  import PlaylistsView from "./views/PlaylistsView.svelte";
  import SearchView from "./views/SearchView.svelte";

  import MiniPlayer from "./MiniPlayer.svelte";
  import FullPlayer from "./FullPlayer.svelte";
  import SideMenu from "./SideMenu.svelte";
  import QueueView from "./views/QueueView.svelte";

  let isMobileMenuOpen = false;

  onMount(() => {
    window.history.replaceState({ depth: $navigationStack.length }, "", "");
    const onPopState = () => handleBrowserBack();
    window.addEventListener("popstate", onPopState);
    return () => window.removeEventListener("popstate", onPopState);
  });
</script>

<div class="app-container">
  <div class="app-layout">
    {#if $toastMessage}
      <div class="toast-container" transition:fly={{ y: -50, duration: 300 }}>
        <div class="toast-body {$toastMessage.type}">
          {$toastMessage.text}
        </div>
      </div>
    {/if}

    <SideMenu
      isOpen={isMobileMenuOpen}
      on:close={() => (isMobileMenuOpen = false)}
    />

    <main class="content-area">
      <header class="top-bar">
        <button
          class="hamburger-btn"
          on:click={() => (isMobileMenuOpen = true)}
        >
          {@html ICONS.MENU}
        </button>

        {#if $navigationStack.length > 1}
          <button class="back-btn" on:click={navigateBack}>
            <span class="icon-inline">{@html ICONS.BACK}</span> Back
          </button>
        {:else}
          <div class="view-title">
            {#if $activeMenuTab === "radio"}Radio
            {:else if $activeMenuTab === "playlists"}Playlists
            {:else if $activeMenuTab === "search"}Search
            {:else if $activeMenuTab === "queue"}Queue
            {:else if $activeMenuTab === "favorites"}Favorites
            {:else}{($activeMenuTab || "Library").charAt(0).toUpperCase() +
                ($activeMenuTab || "library").slice(1)}
            {/if}
          </div>
        {/if}
      </header>

      <div class="scroll-container">
        <div class="view-wrapper">
          {#if $activeMenuTab === "radio"}
            <RadioView />
          {:else if $activeMenuTab === "queue"}
            <QueueView />
          {:else if $activeMenuTab === "playlists" || $activeMenuTab === "favorites"}
            <PlaylistsView />
          {:else if $activeMenuTab === "search"}
            <SearchView />
          {:else}
            <LibraryView activeCategory={$activeMenuTab} />
          {/if}
        </div>
      </div>
    </main>

    <div class="docked-player-container">
      <FullPlayer isDocked={true} />
    </div>
  </div>

  <div class="mini-player-wrapper">
    <MiniPlayer />
  </div>
</div>

{#if $isFullPlayerOpen}
  <div class="full-player-modal">
    <FullPlayer />
  </div>
{/if}

<style>
  .app-container {
    display: flex;
    flex-direction: column;
    width: 100vw;
    height: 100dvh;
    background: var(--c-bg-app);
    overflow: hidden;
  }

  .app-layout {
    display: flex;
    flex: 1;
    min-height: 0;
    position: relative;
    z-index: 1;
  }

  .toast-container {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: var(--z-toast);
  }

  .toast-body {
    background: var(--c-bg-toast);
    color: var(--c-text-primary);
    padding: 12px 24px;
    border-radius: 30px;
    box-shadow: 0 4px 15px var(--c-shadow-popover);
    font-weight: 600;
    font-size: 14px;
  }

  .content-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--c-bg-main);
    min-width: 0;
    height: 100%;
    transition: flex 0.3s ease; /* Smooth resize when side menu toggles */
  }

  .top-bar {
    height: var(--header-height);
    display: flex;
    align-items: center;
    padding: 0 32px;
    background: var(--c-bg-glass);
    border-bottom: 1px solid var(--c-border-dim);
    gap: 15px;
    flex-shrink: 0;
  }

  .scroll-container {
    flex: 1;
    overflow-x: hidden;
    /* padding-bottom: 90px; */
    position: relative;
  }

  .view-wrapper {
    height: 100%;
    width: 100%;
  }

  .hamburger-btn {
    display: none;
    background: none;
    border: none;
    color: var(--c-text-primary);
    cursor: pointer;
  }
  .hamburger-btn :global(svg) {
    width: 24px;
    height: 24px;
  }

  .back-btn {
    background: none;
    border: none;
    color: var(--c-accent);
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 0;
    line-height: 1;
  }

  .icon-inline {
    display: flex;
    align-items: center;
  }

  .back-btn :global(svg) {
    width: 20px;
    height: 20px;
    display: block;
  }

  .view-title {
    font-size: 20px;
    font-weight: 700;
    color: var(--c-text-primary);
  }

  .docked-player-container {
    display: none;
    width: 280px;
    flex-shrink: 0;
    background: var(--c-surface);
    border-left: 1px solid var(--c-border);
    z-index: 5;
  }

  .full-player-modal {
    position: fixed;
    inset: 0;
    z-index: var(--z-modal);
  }

  @media (max-width: 768px) {
    .hamburger-btn {
      display: block;
    }
    .top-bar {
      padding: 0 16px;
    }
  }

  /* --- LANDSCAPE MOBILE OPTIMIZATION --- */
  @media (max-height: 600px) and (orientation: landscape) {
    .top-bar {
      display: none;
    }

    .mini-player-wrapper {
      display: none;
    }

    .scroll-container {
      padding-bottom: 0;
    }

    .docked-player-container {
      display: block;
    }
  }
</style>

=== ./components/ContextMenu.svelte ===
<script>
  import { fade, scale } from "svelte/transition";
  import {
    contextMenu,
    closeContextMenu,
    navigateTo,
    favorites,
    playlists,
    showToast,
    activePlaylistTracks,
  } from "../lib/store";
  import { ICONS } from "../lib/icons";
  import { PlayerActions } from "../lib/mpd/player";
  import { LibraryActions } from "../lib/mpd/library";
  import { mpdClient } from "../lib/mpd/client";

  let innerWidth;
  let innerHeight;
  let menuEl;
  let menuHeight = 0;
  let menuWidth = 0;

  // 'main' | 'playlists'
  let view = "main";

  // Флаг для отслеживания истории браузера
  let historyPushed = false;

  // Сброс вида при открытии
  $: if ($contextMenu.isOpen) {
    view = "main";
  }

  // --- ЛОГИКА ИСТОРИИ (BACK BUTTON / SWIPE) ---
  $: if ($contextMenu.isOpen) {
    // При открытии меню добавляем запись в историю
    if (!historyPushed && typeof history !== "undefined") {
      history.pushState({ contextMenuOpen: true }, "");
      historyPushed = true;
    }
  } else {
    // При закрытии (программном) убираем запись, если она была нами добавлена
    if (historyPushed && typeof history !== "undefined") {
      history.back();
      historyPushed = false;
    }
  }

  function handlePopState(event) {
    // Если нажали "Назад" (или свайпнули) и меню открыто
    if ($contextMenu.isOpen) {
      // Ставим false, чтобы реактивный блок выше не вызывал history.back() повторно
      historyPushed = false;
      closeContextMenu();
    }
  }

  function handleBackdropClick() {
    closeContextMenu();
  }

  // --- ACTIONS ---
  function handlePlayNext() {
    if ($contextMenu.track) PlayerActions.playNext($contextMenu.track.file);
    closeContextMenu();
  }

  function handleAddToQueue() {
    if ($contextMenu.track) PlayerActions.addToQueue($contextMenu.track.file);
    closeContextMenu();
  }

  function handleToggleLike() {
    if ($contextMenu.track) LibraryActions.toggleFavorite($contextMenu.track);
    closeContextMenu();
  }

  function handleGoToAlbum() {
    const t = $contextMenu.track;
    if (t && t.album) {
      navigateTo("tracks_by_album", { name: t.album, artist: t.artist });
    }
    closeContextMenu();
  }

  function handleGoToArtist() {
    const t = $contextMenu.track;
    if (t && t.artist) {
      navigateTo("albums_by_artist", { name: t.artist });
    }
    closeContextMenu();
  }

  // --- PLAYLIST REMOVAL ---
  async function handleRemoveFromPlaylist() {
    const { playlistName, index } = $contextMenu.context;
    if (playlistName && index !== null) {
      activePlaylistTracks.update((tracks) => {
        const copy = [...tracks];
        copy.splice(index, 1);
        return copy;
      });
      await LibraryActions.removeFromPlaylist(playlistName, index);
    }
    closeContextMenu();
  }

  // --- QUEUE REMOVAL ---
  function handleRemoveFromQueue() {
    const { index } = $contextMenu.context;
    if (index !== null && index !== undefined) {
      PlayerActions.removeFromQueue(index);
    }
    closeContextMenu();
  }

  // --- ADD TO PLAYLIST NAV ---
  function showPlaylists() {
    view = "playlists";
  }

  function backToMain() {
    view = "main";
  }

  async function addToPlaylist(playlistName) {
    const track = $contextMenu.track;
    if (!track) return;
    try {
      const safePl = playlistName.replace(/"/g, '\\"');
      const safeFile = track.file.replace(/"/g, '\\"');
      await mpdClient.send(`playlistadd "${safePl}" "${safeFile}"`);
      showToast(`Added to "${playlistName}"`, "success");
      closeContextMenu();
    } catch (e) {
      console.error(e);
      showToast("Failed to add", "error");
    }
  }

  $: isLiked = $contextMenu.track && $favorites.has($contextMenu.track.file);
  $: isRadio =
    $contextMenu.track &&
    ($contextMenu.track.file.includes("http") ||
      $contextMenu.track.file.includes("://"));

  $: isPlaylistContext = $contextMenu.context?.type === "playlist";
  $: isQueueContext = $contextMenu.context?.type === "queue";
  $: isMiniPlayerSource = $contextMenu.context?.source === "miniplayer";

  // --- POSITIONING ALGORITHM ---
  $: stylePosition = (() => {
    if (!$contextMenu.isOpen) return "";

    const rect = $contextMenu.triggerRect;
    const clickX = $contextMenu.x;
    const clickY = $contextMenu.y;

    const mw = menuWidth || 220;
    const mh = menuHeight || 320;

    // 1. MOBILE MINI-PLAYER SPECIAL CASE
    if (innerWidth <= 768 && isMiniPlayerSource && rect) {
      const bottomPos = innerHeight - rect.top;
      return `
        position: fixed; 
        bottom: ${bottomPos}px; 
        left: 50%; 
        transform: translateX(-50%); 
        margin: 0; 
        transform-origin: bottom center;
      `;
    }

    // 2. GENERAL POSITIONING (Tracks, Desktop)
    let left = 0;
    let top = 0;
    let transformOrigin = "top left";

    if (rect) {
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      const isRightHalf = centerX > innerWidth / 2;
      const isBottomHalf = centerY > innerHeight / 2;

      // Горизонталь
      if (isRightHalf) {
        left = rect.right - mw;
        transformOrigin = isBottomHalf ? "bottom right" : "top right";
      } else {
        left = rect.left;
        transformOrigin = isBottomHalf ? "bottom left" : "top left";
      }

      // Вертикаль
      if (isBottomHalf) {
        top = rect.top - mh;
      } else {
        top = rect.bottom;
      }
    } else {
      // Fallback
      left = clickX;
      top = clickY;
      if (left + mw > innerWidth) left = innerWidth - mw - 10;
      if (top + mh > innerHeight) top = innerHeight - mh - 10;
    }

    // Защита от вылета за границы экрана
    const padding = 8;
    if (left < padding) left = padding;
    if (left + mw > innerWidth - padding) left = innerWidth - mw - padding;
    if (top < padding) top = padding;
    if (top + mh > innerHeight - padding) top = innerHeight - mh - padding;

    return `position: fixed; top: ${top}px; left: ${left}px; margin: 0; transform-origin: ${transformOrigin};`;
  })();
</script>

<svelte:window bind:innerWidth bind:innerHeight on:popstate={handlePopState} />

{#if $contextMenu.isOpen}
  <div
    class="backdrop"
    on:click={handleBackdropClick}
    transition:fade={{ duration: 100 }}
  >
    <div
      class="menu-card"
      bind:this={menuEl}
      bind:clientHeight={menuHeight}
      bind:clientWidth={menuWidth}
      style={stylePosition}
      transition:scale={{ start: 0.95, duration: 100 }}
      on:click|stopPropagation
    >
      <div class="menu-header">
        {#if view === "playlists"}
          <button class="back-btn-area" on:click={backToMain}>
            <span class="back-icon">{@html ICONS.BACK}</span>
          </button>
          <span class="header-title">Select Playlist</span>
        {:else}
          <div class="track-info">
            <div class="title text-ellipsis">{$contextMenu.track.title}</div>
            <div class="artist text-ellipsis">{$contextMenu.track.artist}</div>
          </div>
        {/if}
      </div>

      <div class="menu-items scroll-y">
        {#if view === "playlists"}
          {#each $playlists as pl}
            {#if pl.name !== "Favorites"}
              <button class="menu-row" on:click={() => addToPlaylist(pl.name)}>
                <span class="icon">{@html ICONS.PLAYLISTS}</span>
                <span>{pl.name}</span>
              </button>
            {/if}
          {/each}
          {#if $playlists.filter((p) => p.name !== "Favorites").length === 0}
            <div class="empty-msg">No custom playlists</div>
          {/if}
        {:else}
          <button class="menu-row" on:click={handlePlayNext}>
            <span class="icon">{@html ICONS.NEXT}</span>
            <span>Play Next</span>
          </button>

          <button class="menu-row" on:click={handleAddToQueue}>
            <span class="icon">{@html ICONS.MENU}</span>
            <span>Add to Queue</span>
          </button>

          <button class="menu-row" on:click={showPlaylists}>
            <span class="icon">{@html ICONS.ADD_TO_PLAYLIST || ICONS.ADD}</span>
            <span>Add to Playlist...</span>
          </button>

          {#if !isRadio}
            <button class="menu-row" on:click={handleGoToAlbum}>
              <span class="icon">{@html ICONS.ALBUM_LINK || ICONS.ALBUMS}</span>
              <span>Go to Album</span>
            </button>

            <button class="menu-row" on:click={handleGoToArtist}>
              <span class="icon"
                >{@html ICONS.ARTIST_LINK || ICONS.ARTISTS}</span
              >
              <span>Go to Artist</span>
            </button>
          {/if}

          <button class="menu-row" on:click={handleToggleLike}>
            <span class="icon" class:liked={isLiked}>
              {@html isLiked ? ICONS.HEART_FILLED : ICONS.HEART}
            </span>
            <span>{isLiked ? "Unlike" : "Like"}</span>
          </button>

          {#if isPlaylistContext}
            <div class="sep"></div>
            <button class="menu-row" on:click={handleRemoveFromPlaylist}>
              <span class="icon">{@html ICONS.REMOVE}</span>
              <span>Remove from Playlist</span>
            </button>
          {/if}

          {#if isQueueContext}
            <div class="sep"></div>
            <button class="menu-row" on:click={handleRemoveFromQueue}>
              <span class="icon">{@html ICONS.REMOVE}</span>
              <span>Remove from Queue</span>
            </button>
          {/if}
        {/if}
      </div>
    </div>
  </div>
{/if}

<style>
  .backdrop {
    position: fixed;
    inset: 0;
    z-index: var(--z-modal);
    background: transparent;
    backdrop-filter: blur(2px);
  }

  .menu-card {
    background: #1e1e1e;
    width: 220px;
    max-height: 400px;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid var(--c-border);
    z-index: 10001;
  }

  .menu-header {
    padding: 0;
    height: 50px;
    background: rgba(255, 255, 255, 0.04);
    border-bottom: 1px solid var(--c-border);
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }

  .track-info {
    padding: 0 14px;
    overflow: hidden;
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    height: 100%;
  }

  .title {
    font-size: 13px;
    font-weight: 700;
    color: var(--c-text-primary);
    margin-bottom: 2px;
  }

  .artist {
    font-size: 12px;
    color: var(--c-text-secondary);
  }

  .header-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--c-text-primary);
    padding-right: 14px;
  }

  .back-btn-area {
    background: none;
    border: none;
    color: var(--c-text-primary);
    width: 48px;
    height: 100%;
    padding: 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 4px;
  }
  .back-btn-area:active {
    background: rgba(255, 255, 255, 0.1);
  }
  .back-icon {
    width: 20px;
    height: 20px;
    display: block;
  }
  .back-icon :global(svg) {
    width: 100%;
    height: 100%;
  }

  .menu-items {
    padding: 6px 0;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }

  .menu-row {
    display: flex;
    align-items: center;
    padding: 12px 14px;
    background: transparent;
    border: none;
    color: var(--c-text-primary);
    font-size: 14px;
    text-align: left;
    cursor: pointer;
    transition: background 0.1s;
    width: 100%;
  }

  .menu-row:active,
  .menu-row:hover {
    background: var(--c-surface-hover);
  }

  .icon {
    width: 20px;
    height: 20px;
    margin-right: 14px;
    color: var(--c-text-secondary);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .icon.liked {
    color: var(--c-accent);
  }
  .icon.liked :global(svg) {
    stroke: none;
  }

  .sep {
    height: 1px;
    background: var(--c-border);
    margin: 6px 16px;
    opacity: 0.3;
  }

  .empty-msg {
    padding: 16px;
    text-align: center;
    color: var(--c-text-muted);
    font-size: 13px;
  }
</style>

=== ./components/VirtualList.svelte ===
<script>
  import { createEventDispatcher } from "svelte";
  const dispatch = createEventDispatcher();

  export let items = [];
  export let itemHeight = 60; // Высота строки в px
  export let component; // Компонент строки (TrackRow)
  export let componentProps = {};

  let height = "100%";
  let scrollTop = 0;
  let viewportHeight = 0;
  let container;

  // Рассчитываем, какие элементы показывать
  $: totalHeight = items.length * itemHeight;
  $: startIndex = Math.floor(scrollTop / itemHeight);
  $: endIndex = Math.min(
    items.length,
    startIndex + Math.ceil(viewportHeight / itemHeight) + 4, // +4 буфер
  );
  $: visibleItems = items.slice(startIndex, endIndex).map((data, i) => ({
    index: startIndex + i,
    data,
  }));
  $: paddingTop = startIndex * itemHeight;

  function handleScroll(e) {
    scrollTop = e.target.scrollTop;
  }
</script>

<div
  class="virtual-scroll-container"
  bind:this={container}
  bind:clientHeight={viewportHeight}
  on:scroll={handleScroll}
  style="height: {height};"
>
  <div
    class="virtual-scroll-content"
    style="height: {totalHeight}px; padding-top: {paddingTop}px; box-sizing: border-box;"
  >
    {#each visibleItems as item (item.index)}
      <svelte:component
        this={component}
        track={item.data}
        index={item.index}
        {...componentProps}
        on:play={() => dispatch("play", { track: item.data })}
      />
    {/each}
  </div>
</div>

<style>
  .virtual-scroll-container {
    width: 100%;
    height: 100%;
    overflow-y: auto;
    position: relative;
    /* Кастомный скроллбар */
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
  }
  .virtual-scroll-container::-webkit-scrollbar {
    width: 6px;
  }
  .virtual-scroll-container::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
  }
  .virtual-scroll-content {
    width: 100%;
  }
</style>

=== ./components/Skeleton.svelte ===
<script>
  export let width = "100%";
  export let height = "20px";
  export let radius = "4px";
  export let style = "";
</script>

<div
  class="skeleton"
  style="width: {width}; height: {height}; border-radius: {radius}; {style}"
></div>

<style>
  .skeleton {
    background: var(--c-skeleton-base);
    animation: pulse 1.5s infinite ease-in-out;
  }
  @keyframes pulse {
    0% {
      opacity: 0.6;
    }
    50% {
      opacity: 0.3;
    }
    100% {
      opacity: 0.6;
    }
  }
</style>

=== ./components/FullPlayer.svelte ===
<script>
  import { fly } from "svelte/transition";
  import * as MPD from "../lib/mpd";
  import { ICONS } from "../lib/icons";
  import { LibraryActions } from "../lib/mpd/library";
  import {
    currentSong,
    status,
    isFullPlayerOpen,
    favorites,
    getTrackCoverUrl,
    stations,
  } from "../lib/store.js";
  import ImageLoader from "./ImageLoader.svelte";

  export let isDocked = false;

  let startY = 0;
  let currentY = 0;
  let isDraggingPlayer = false;

  function close() {
    isFullPlayerOpen.set(false);
  }

  function handleTouchStart(e) {
    if (isDocked) return;
    const target = e.target;
    if (target.closest(".bar-hit-area") || target.closest(".volume-hit-area"))
      return;

    startY = e.touches[0].clientY;
    isDraggingPlayer = true;
  }

  function handleTouchMove(e) {
    if (!isDraggingPlayer || isDocked) return;
    const delta = e.touches[0].clientY - startY;
    if (delta > 0) {
      if (e.cancelable && delta > 10) e.preventDefault();
      currentY = delta;
    }
  }

  function handleTouchEnd() {
    if (isDocked) return;
    isDraggingPlayer = false;
    if (currentY > 150) close();
    else currentY = 0;
  }

  $: artSrc = getTrackCoverUrl(
    $currentSong,
    $stations,
    $currentSong.stationName,
  );

  let isDraggingBar = false;
  let dragProgress = 0;
  let progressBar;

  $: duration = $status.duration || 1;
  $: elapsed = $status.elapsed || 0;
  $: isRadio = $currentSong.file?.startsWith("http");
  $: isPlaying = $status.state === "play";
  $: isSmooth = isPlaying && !isDraggingBar && !isRadio;

  $: progressPct = isRadio
    ? 0
    : isDraggingBar
      ? dragProgress * 100
      : (elapsed / duration) * 100;

  function formatTime(seconds) {
    const m = Math.floor(seconds / 60) || 0;
    const s = Math.floor(seconds % 60) || 0;
    return `${m}:${s.toString().padStart(2, "0")}`;
  }

  function getPct(e, element) {
    const rect = element.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    return Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
  }

  function handleSeekStart(e) {
    if (isRadio) return;
    isDraggingBar = true;
    dragProgress = getPct(e, progressBar);
  }

  function handleSeekMove(e) {
    if (isDraggingBar) dragProgress = getPct(e, progressBar);
  }

  function handleSeekEnd() {
    if (isDraggingBar && !isRadio) {
      MPD.seek(dragProgress * duration);
    }
    isDraggingBar = false;
  }

  let isDraggingVol = false;
  let volumeBar;

  function handleVolStart(e) {
    isDraggingVol = true;
    const vol = Math.round(getPct(e, volumeBar) * 100);
    MPD.setVolume(vol);
    window.addEventListener("mousemove", onVolMove);
    window.addEventListener("mouseup", onVolEnd);
    window.addEventListener("touchmove", onVolMove, { passive: false });
    window.addEventListener("touchend", onVolEnd);
  }

  function onVolMove(e) {
    if (isDraggingVol) {
      e.preventDefault();
      const vol = Math.round(getPct(e, volumeBar) * 100);
      MPD.setVolume(vol);
    }
  }

  function onVolEnd() {
    isDraggingVol = false;
    window.removeEventListener("mousemove", onVolMove);
    window.removeEventListener("mouseup", onVolEnd);
    window.removeEventListener("touchmove", onVolMove);
    window.removeEventListener("touchend", onVolEnd);
  }

  $: currentMode = $status.repeat ? 2 : $status.random ? 1 : 0;

  function togglePlayMode() {
    const nextMode = (currentMode + 1) % 3;
    if (nextMode === 0) {
      if ($status.random) MPD.toggleRandom();
      if ($status.repeat) MPD.toggleRepeat();
    } else if (nextMode === 1) {
      if (!$status.random) MPD.toggleRandom();
      if ($status.repeat) MPD.toggleRepeat();
    } else if (nextMode === 2) {
      if ($status.random) MPD.toggleRandom();
      if (!$status.repeat) MPD.toggleRepeat();
    }
  }

  $: qualityLabel = $status.bitrate
    ? `${$status.bitrate} kbps`
    : $status.format || "";
  $: isLiked = $currentSong.file && $favorites.has($currentSong.file);

  $: artworkRadius = isDocked ? "8px" : "var(--radius-xl)";
</script>

<div
  class="full-player"
  class:is-docked={isDocked}
  transition:fly={{ y: isDocked ? 0 : 800, duration: 300, opacity: 1 }}
  style={!isDocked
    ? `transform: translateY(${currentY}px); transition: ${isDraggingPlayer ? "none" : "transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)"}`
    : ""}
>
  {#if !isDocked}
    <div
      class="drag-zone"
      on:touchstart={handleTouchStart}
      on:touchmove={handleTouchMove}
      on:touchend={handleTouchEnd}
      on:click={close}
    >
      <div class="drag-handle-icon">
        {@html ICONS.CHEVRON_DOWN}
      </div>
    </div>
  {/if}

  <div class="bg-container">
    <div class="bg-gradient-fallback"></div>
    <img class="bg-img" src={artSrc} alt="" loading="eager" />
    <div class="bg-overlay"></div>
  </div>

  <div class="player-body">
    <div class="art-container">
      <div class="artwork" style="transform: scale({1 - currentY / 3000})">
        <ImageLoader src={artSrc} alt="Cover" radius={artworkRadius}>
          <div slot="fallback" class="icon-fallback">
            {@html isRadio ? ICONS.RADIO : ICONS.ALBUMS}
          </div>
        </ImageLoader>
      </div>
    </div>

    <div class="controls-area" style="opacity: {1 - currentY / 400}">
      <div class="meta">
        <h1 class="title text-ellipsis">
          {$currentSong.title || "Not Playing"}
        </h1>
        <div class="artist-row">
          <h2 class="artist text-ellipsis">
            {$currentSong.stationName || $currentSong.artist || "Moode Audio"}
          </h2>
          {#if qualityLabel}
            <span class="quality-badge">{qualityLabel}</span>
          {/if}
        </div>
      </div>

      <div class="progress-section">
        <div
          class="bar-hit-area"
          class:is-docked-bar={isDocked}
          bind:this={progressBar}
          on:mousedown={handleSeekStart}
          on:touchstart|passive={handleSeekStart}
          on:mousemove={isDraggingBar ? handleSeekMove : null}
          on:touchmove|passive={isDraggingBar ? handleSeekMove : null}
          on:mouseup={handleSeekEnd}
          on:touchend={handleSeekEnd}
        >
          <div class="common-track">
            <div
              class="common-fill"
              style="width: {progressPct}%; transition: {isSmooth
                ? 'width 0.3s linear'
                : 'none'}"
            >
              <div class="common-knob"></div>
            </div>
          </div>
        </div>
        <div class="time-row">
          <span
            >{isDraggingBar
              ? formatTime(dragProgress * duration)
              : formatTime(elapsed)}</span
          >
          <span>{isRadio ? "LIVE" : formatTime(duration)}</span>
        </div>
      </div>

      <div class="buttons-row">
        <button
          class="btn-icon side-btn"
          class:liked={isLiked}
          on:click={() => LibraryActions.toggleFavorite($currentSong)}
        >
          {@html isLiked ? ICONS.HEART_FILLED : ICONS.HEART}
        </button>

        <button class="btn-icon side-btn" on:click={() => MPD.nav("previous")}>
          {@html ICONS.PREVIOUS}
        </button>

        <button class="play-btn-large flex-center" on:click={MPD.togglePlay}>
          {@html $status.state === "play" ? ICONS.PAUSE : ICONS.PLAY}
        </button>

        <button class="btn-icon side-btn" on:click={() => MPD.nav("next")}>
          {@html ICONS.NEXT}
        </button>

        {#if !isRadio}
          <button
            class="btn-icon side-btn mode-btn"
            class:active={currentMode > 0}
            on:click={togglePlayMode}
          >
            {#if currentMode === 2}
              {@html ICONS.REPEAT}
            {:else}
              {@html ICONS.SHUFFLE}
            {/if}
            {#if currentMode > 0}<span class="dot"></span>{/if}
          </button>
        {:else}
          <div style="width: 44px;"></div>
        {/if}
      </div>

      <div class="volume-row">
        <div class="vol-icon">{@html ICONS.VOLUME}</div>
        <div
          class="volume-hit-area"
          bind:this={volumeBar}
          on:mousedown|stopPropagation={handleVolStart}
          on:touchstart|stopPropagation={handleVolStart}
        >
          <div class="common-track">
            <div class="common-fill" style="width: {$status.volume}%"></div>
            <div
              class="common-knob"
              style="left: {$status.volume}%; right: auto;"
            ></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* --- MAIN CONTAINER --- */
  .full-player {
    position: fixed;
    inset: 0;
    z-index: var(--z-modal);
    background: var(--c-bg-app);
    display: flex;
    flex-direction: column;
    touch-action: none;
  }

  .full-player.is-docked {
    position: relative;
    inset: auto;
    z-index: 1;
    width: 100%;
    height: 100%;
    background: transparent;
    border-left: 1px solid var(--c-border);
    overflow: hidden;
  }

  /* --- BACKGROUND SYSTEM --- */
  .bg-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    overflow: hidden;
    pointer-events: none;
  }

  .bg-gradient-fallback {
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, #121212 0%, #000000 100%);
    z-index: 1;
  }

  .bg-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 2;
    transform: scale(1.6);
    filter: blur(50px) brightness(1.1) saturate(3) contrast(1.2);
    opacity: 0.8;
    transition: opacity 0.5s ease-in;
  }

  .bg-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 3;
    background: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0.6) 0%,
      rgba(0, 0, 0, 0.95) 100%
    );
  }

  /* DOCKED MODE OVERRIDES */
  .is-docked .bg-img {
    filter: blur(35px) brightness(1.2) saturate(3.5);
    opacity: 1;
  }

  .is-docked .bg-overlay {
    background: rgba(0, 0, 0, 0.7);
  }

  /* --- CONTENT --- */
  .player-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 0 24px 40px;
    max-width: 500px;
    width: 100%;
    margin: 0 auto;
    box-sizing: border-box;
    justify-content: center;
    gap: 30px;
    position: relative;
    z-index: 4;
  }

  .is-docked .player-body {
    padding: 10px 16px 16px;
    gap: 12px;
    justify-content: flex-end;
    max-width: 100%;
  }

  /* --- DRAG ZONE --- */
  .drag-zone {
    height: 30vh;
    width: 100%;
    position: absolute;
    top: 0;
    z-index: 10;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 15px;
    cursor: pointer;
  }
  .drag-handle-icon {
    color: rgba(255, 255, 255, 0.3);
    transition: color 0.2s;
    width: 32px;
    height: 32px;
  }
  .drag-zone:active .drag-handle-icon {
    color: rgba(255, 255, 255, 0.6);
  }
  .drag-handle-icon :global(svg) {
    width: 100%;
    height: 100%;
    stroke-width: 3;
  }

  /* --- ARTWORK --- */
  .art-container {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    flex-grow: 0;
    margin-bottom: 10px;
    flex-shrink: 1;
    min-height: 0;
  }
  .is-docked .art-container {
    flex: 1 1 auto;
    margin-bottom: 0;
    height: 100%;
    max-height: 50vh;
    overflow: hidden;
  }

  .artwork {
    width: 100%;
    max-width: 400px;
    aspect-ratio: 1;
    background: var(--c-bg-placeholder);
    border-radius: var(--radius-xl);
    box-shadow: var(--c-shadow-popover);
    overflow: hidden;
    will-change: transform;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .is-docked .artwork {
    height: 100%;
    width: auto;
    max-width: 100%;
    border-radius: 8px;
    box-shadow: none;
    aspect-ratio: 1/1;
  }

  .artwork :global(img) {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .icon-fallback {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--c-icon-faint);
  }
  .icon-fallback :global(svg) {
    width: 100px;
    height: 100px;
    opacity: 0.5;
  }

  /* --- CONTROLS --- */
  .controls-area {
    display: flex;
    flex-direction: column;
    gap: 20px;
    flex-shrink: 0;
    width: 100%;
  }
  .is-docked .controls-area {
    gap: 8px;
    flex: 0 0 auto;
  }

  .meta {
    text-align: left;
    margin-bottom: 10px;
  }
  .is-docked .meta {
    text-align: center;
    margin-bottom: 4px;
  }

  .title {
    font-size: 24px;
    font-weight: 700;
    margin: 0 0 4px;
    color: var(--c-text-primary);
  }
  .is-docked .title {
    font-size: 16px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .artist-row {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
  }
  .is-docked .artist-row {
    justify-content: center;
  }

  .artist {
    font-size: 18px;
    color: var(--c-text-secondary);
    margin: 0;
    flex-shrink: 1;
  }
  .is-docked .artist {
    font-size: 13px;
  }

  /* --- BARS & BUTTONS --- */
  .bar-hit-area,
  .volume-hit-area {
    height: 40px;
    display: flex;
    align-items: center;
    cursor: pointer;
    touch-action: none;
    position: relative;
    width: 100%;
  }
  .is-docked-bar {
    height: 24px;
  }

  .volume-hit-area {
    flex: 1;
  }

  .common-track {
    width: 100%;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    position: relative;
  }

  .common-fill {
    height: 100%;
    background: var(--c-text-primary);
    border-radius: 2px;
    position: relative;
    left: 0;
    top: 0;
    pointer-events: none;
  }

  .volume-hit-area .common-fill {
    position: absolute;
  }

  .common-knob {
    position: absolute;
    top: 50%;
    margin-top: -7px;
    right: -7px;
    width: 14px;
    height: 14px;
    background: #fff;
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    pointer-events: none;
  }

  .volume-hit-area .common-knob {
    transform: translateX(-50%);
    right: auto;
    margin-top: -7px;
  }

  .time-row {
    display: flex;
    justify-content: space-between;
    margin-top: -12px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.9);
    font-weight: 600;
    font-variant-numeric: tabular-nums;
  }
  .is-docked .time-row {
    margin-top: 0px;
    font-size: 10px;
  }

  .buttons-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 8px;
  }
  .is-docked .buttons-row {
    justify-content: space-between;
    gap: 0;
    padding: 0 8px;
  }

  .side-btn {
    padding: 10px;
    color: var(--c-text-secondary);
    transition: color 0.2s;
  }
  .side-btn:active {
    opacity: 0.7;
  }
  .side-btn.active,
  .side-btn.liked {
    color: var(--c-accent);
  }
  .side-btn :global(svg) {
    width: 24px;
    height: 24px;
  }
  .is-docked .side-btn {
    padding: 6px;
  }
  .is-docked .side-btn :global(svg) {
    width: 20px;
    height: 20px;
  }

  .play-btn-large {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: var(--c-text-primary);
    color: var(--c-text-inverse);
    box-shadow: var(--c-shadow-card);
    transition: transform 0.1s;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  .play-btn-large:active {
    transform: scale(0.95);
  }
  .play-btn-large :global(svg) {
    width: 28px;
    height: 28px;
    fill: currentColor;
  }
  .is-docked .play-btn-large {
    width: 44px;
    height: 44px;
  }
  .is-docked .play-btn-large :global(svg) {
    width: 20px;
    height: 20px;
  }

  .mode-btn {
    position: relative;
  }
  .dot {
    position: absolute;
    bottom: 6px;
    width: 4px;
    height: 4px;
    background: var(--c-accent);
    border-radius: 50%;
    left: 50%;
    transform: translateX(-50%);
  }
  .is-docked .dot {
    bottom: 2px;
    width: 3px;
    height: 3px;
  }

  .volume-row {
    display: flex;
    align-items: center;
    gap: 16px;
    opacity: 0.9;
    padding: 0 4px;
  }
  .vol-icon :global(svg) {
    width: 20px;
    height: 20px;
    fill: var(--c-text-secondary);
  }
  .is-docked .volume-row {
    gap: 8px;
  }
  .is-docked .vol-icon :global(svg) {
    width: 16px;
    height: 16px;
  }
</style>

=== ./components/views/RadioView.svelte ===
<script>
  import { fade } from "svelte/transition";
  import {
    stations,
    currentSong,
    status,
    isLoadingRadio,
  } from "../../lib/store";
  import * as MPD from "../../lib/mpd";
  import { getStationImageUrl } from "../../lib/utils";
  import { ICONS } from "../../lib/icons";
  import ImageLoader from "../ImageLoader.svelte";
  import Skeleton from "../Skeleton.svelte";

  let searchTerm = "";

  $: filteredStations = $stations.filter((s) => {
    const q = searchTerm.toLowerCase();
    return (
      s.name.toLowerCase().includes(q) ||
      (s.genre && s.genre.toLowerCase().includes(q))
    );
  });

  $: qualityLabel = $status.bitrate
    ? `${$status.bitrate} kbps`
    : $status.format || "";
</script>

<div
  class="view-container scrollable content-padded"
  in:fade={{ duration: 200 }}
>
  <div class="search-input-container">
    <span class="search-icon">
      {@html ICONS.SEARCH}
    </span>
    <input type="text" placeholder="Find station..." bind:value={searchTerm} />
  </div>

  {#if $isLoadingRadio}
    <div class="music-grid">
      {#each Array(12) as _}
        <div class="music-card">
          <Skeleton
            width="100%"
            style="aspect-ratio: 1; border-radius: 8px; margin-bottom: 12px;"
          />
          <Skeleton width="70%" height="16px" />
        </div>
      {/each}
    </div>
  {:else}
    <div class="music-grid">
      {#each filteredStations as station}
        {@const streamUrl = station.file}
        {@const isActive =
          $currentSong.stationName === station.name ||
          $currentSong.file === streamUrl}
        {@const imgUrl = getStationImageUrl(station)}

        <div
          class="music-card"
          class:is-active={isActive}
          role="button"
          tabindex="0"
          on:click={() => MPD.playStation(station)}
        >
          <div class="card-img-container">
            <ImageLoader
              src={imgUrl}
              alt={station.name}
              radius="var(--radius-md)"
            >
              <div slot="fallback" class="icon-fallback">📻</div>
            </ImageLoader>

            {#if isActive && qualityLabel}
              <div class="quality-tag" in:fade>{qualityLabel}</div>
            {/if}

            <div class="play-overlay">
              {#if isActive}
                {#if $status.state === "play"}
                  <div class="status-badge playing">PLAYING</div>
                {:else}
                  <div class="status-badge paused">PAUSED</div>
                {/if}
              {:else}
                <span style="width: 48px; color: #fff;">{@html ICONS.PLAY}</span
                >
              {/if}
            </div>
          </div>

          <div class="card-title text-ellipsis">
            {station.name}
          </div>
          {#if station.genre}
            <div class="card-sub text-ellipsis">{station.genre}</div>
          {/if}
        </div>
      {/each}
    </div>

    {#if filteredStations.length === 0 && $stations.length > 0}
      <div class="empty-text">
        <div style="font-size: 40px; margin-bottom: 10px;">🔍</div>
        <div>No stations found</div>
      </div>
    {/if}
  {/if}
</div>

<style>
  @import "./MusicViews.css";

  .quality-tag {
    position: absolute;
    top: 6px;
    right: 6px;
    z-index: 5;
    background: var(--c-bg-glass);
    color: var(--c-text-primary);
    font-size: 9px;
    font-weight: 800;
    padding: 2px 5px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--c-border);
  }

  .status-badge {
    font-size: 10px;
    font-weight: 800;
    padding: 4px 8px;
    border-radius: var(--radius-sm);
    color: var(--c-text-primary);
  }
  .status-badge.playing {
    background: var(--c-accent);
  }
  .status-badge.paused {
    background: var(--c-bg-toast);
    border: 1px solid var(--c-border);
  }
</style>

=== ./components/views/SearchView.svelte ===
<script>
  import { onMount } from "svelte";
  import { writable } from "svelte/store";
  import { db } from "../../lib/db";
  import TrackRow from "../TrackRow.svelte";
  import ImageLoader from "../ImageLoader.svelte";
  import * as MPD from "../../lib/mpd";
  import { ICONS } from "../../lib/icons";
  import { navigateTo, getTrackThumbUrl, searchQuery } from "../../lib/store";
  import BaseList from "./BaseList.svelte";

  const tracksStore = writable([]);

  let foundAlbums = [];
  let isSearching = false;
  let debounceTimer;
  let hasSearched = false;

  onMount(() => {
    if ($searchQuery.length >= 2) {
      performSearch($searchQuery);
    }
  });

  function handleInput(e) {
    searchQuery.set(e.target.value);

    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      performSearch($searchQuery);
    }, 300);
  }

  function clearInput() {
    searchQuery.set("");
    tracksStore.set([]);
    foundAlbums = [];
    hasSearched = false;
  }

  async function performSearch(q) {
    const term = q.trim().toLowerCase();

    if (term.length < 2) {
      tracksStore.set([]);
      foundAlbums = [];
      hasSearched = false;
      return;
    }

    isSearching = true;
    hasSearched = true;

    try {
      const results = await db.search(term);

      const tracksWithIds = results.map((t, i) => ({
        ...t,
        _uid: t.file ? `${t.file}-${i}` : `search-${i}`,
      }));

      tracksStore.set(tracksWithIds);

      const albumMap = new Map();
      results.forEach((track) => {
        const albumName = track.album;
        if (albumName && !albumMap.has(albumName)) {
          const matchAlbum = albumName.toLowerCase().includes(term);
          const matchArtist =
            track.artist && track.artist.toLowerCase().includes(term);

          if (matchAlbum || matchArtist) {
            let yStr = String(track.year || "");
            if (yStr.length > 4) yStr = yStr.substring(0, 4);

            albumMap.set(albumName, {
              name: albumName,
              artist: track.artist,
              file: track.file,
              thumbHash: track.thumbHash,
              _uid: `alb-${albumName}`,
              year: yStr,
              qualityBadge: track.qualityBadge,
            });
          }
        }
      });
      foundAlbums = Array.from(albumMap.values());
    } finally {
      isSearching = false;
    }
  }

  function playTrack(track) {
    MPD.playTrackOptimistic(track);
  }

  function goToAlbum(album) {
    navigateTo("tracks_by_album", { name: album.name, artist: album.artist });
  }

  function handleHorizontalScroll(e) {
    if (e.deltaY !== 0) {
      e.currentTarget.scrollLeft += e.deltaY;
    }
  }
</script>

<div class="view-container">
  <div class="content-padded" style="padding-bottom: 0;">
    <div class="search-input-container">
      <span class="search-icon">{@html ICONS.SEARCH}</span>
      <input
        type="text"
        placeholder="Artists, songs, or albums"
        value={$searchQuery}
        on:input={handleInput}
        autoFocus
      />

      {#if $searchQuery.length > 0}
        <button class="clear-icon-btn" on:click={clearInput}>
          {@html ICONS.CLOSE}
        </button>
      {/if}

      {#if isSearching}
        <div class="spinner"></div>
      {/if}
    </div>
  </div>

  <BaseList
    itemsStore={tracksStore}
    isEditMode={false}
    isLoading={false}
    emptyText=""
  >
    <div slot="header" class="content-padded">
      {#if $searchQuery.length < 2}
        <div class="placeholder-state">
          <div class="placeholder-icon">🔍</div>
          <p>Type to search your library</p>
        </div>
      {:else if !isSearching && $tracksStore.length === 0 && foundAlbums.length === 0 && hasSearched}
        <div class="empty-text">No results found for "{$searchQuery}"</div>
      {:else}
        {#if foundAlbums.length > 0}
          <div class="header-label section-spacing">Albums</div>

          <div
            class="music-grid horizontal section-mb"
            on:wheel={handleHorizontalScroll}
          >
            {#each foundAlbums as album (album._uid)}
              <div class="music-card" on:click={() => goToAlbum(album)}>
                <div class="card-img-container">
                  <ImageLoader
                    src={getTrackThumbUrl(album, "md")}
                    alt={album.name}
                    radius="var(--radius-md)"
                  >
                    <div slot="fallback" class="icon-fallback">💿</div>
                  </ImageLoader>

                  <div class="play-overlay">
                    <span style="width: 48px; color: #fff;"
                      >{@html ICONS.PLAY}</span
                    >
                  </div>
                </div>

                <div class="card-title text-ellipsis" title={album.name}>
                  {album.name}
                </div>

                <div class="card-sub-row">
                  <div class="card-sub text-ellipsis">{album.artist}</div>
                  {#if album.year && album.year !== "0"}
                    <div class="card-year">{album.year}</div>
                  {/if}
                  {#if album.qualityBadge}
                    <div class="card-year quality">
                      {album.qualityBadge.split(" ")[0]}
                    </div>
                  {/if}
                </div>
              </div>
            {/each}
          </div>
        {/if}

        {#if $tracksStore.length > 0}
          <div class="header-label">Tracks</div>
        {/if}
      {/if}
    </div>

    <div slot="row" let:item let:index>
      <TrackRow
        track={item}
        {index}
        isEditable={false}
        on:play={() => playTrack(item)}
      />
    </div>
  </BaseList>
</div>

<style>
  @import "./MusicViews.css";

  .clear-icon-btn {
    background: transparent;
    border: none;
    color: var(--c-text-muted);
    width: 24px;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    padding: 0;
    margin-right: 4px;
  }
  .clear-icon-btn :global(svg) {
    width: 16px;
    height: 16px;
  }

  .section-spacing {
    margin-top: 10px;
  }

  .section-mb {
    margin-bottom: 24px;
  }

  .placeholder-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 40vh;
    color: var(--c-text-secondary);
  }

  .placeholder-icon {
    font-size: 60px;
    margin-bottom: 20px;
    color: var(--c-icon-faint);
  }

  .spinner {
    width: 16px;
    height: 16px;
    border: 2px solid var(--c-border);
    border-top-color: var(--c-accent);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    margin-left: 8px;
    flex-shrink: 0;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .music-grid.horizontal {
    display: flex;
    flex-wrap: nowrap;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    gap: 16px;
  }

  .music-grid.horizontal::-webkit-scrollbar {
    display: none;
  }

  .music-grid.horizontal .music-card {
    flex: 0 0 auto;
    width: 210px;
    scroll-snap-align: start;
    margin: 0;
  }
</style>

=== ./components/views/PlaylistsView.svelte ===
<script>
  import { onMount } from "svelte";
  import {
    playlists,
    isLoadingPlaylists,
    activePlaylistTracks,
    isLoadingTracks,
    navigationStack,
    navigateTo,
  } from "../../lib/store";
  import Skeleton from "../Skeleton.svelte";
  import * as MPD from "../../lib/mpd";
  import { ICONS } from "../../lib/icons";
  import TrackRow from "../TrackRow.svelte";
  import BaseList from "./BaseList.svelte";

  let isEditMode = false;
  let pressedPlayAll = false;
  let pressedAddToQueue = false;
  let playlistDuration = "";
  let playlistQuality = "";

  $: currentView = $navigationStack[$navigationStack.length - 1];
  $: isDetailsView = currentView.view === "details";

  $: if (currentView) {
    pressedPlayAll = false;
    pressedAddToQueue = false;
  }

  $: if (isDetailsView && $activePlaylistTracks.length > 0) {
    const tracks = $activePlaylistTracks;
    if (!tracks[0]._uid) {
      const styledTracks = tracks.map((t) => ({ ...t, _uid: Math.random() }));
      activePlaylistTracks.set(styledTracks);
    }
    calculateMeta(tracks);
  } else if (
    isDetailsView &&
    $activePlaylistTracks.length === 0 &&
    !$isLoadingTracks
  ) {
    playlistDuration = "0 min";
    playlistQuality = "";
  }

  $: if (isDetailsView && currentView.data) {
    isEditMode = false;
    MPD.openPlaylistDetails(currentView.data.name);
  }

  onMount(() => {
    if (!isDetailsView && $playlists.length === 0) {
      MPD.loadPlaylists();
    }
  });

  function calculateMeta(tracks) {
    const totalSec = tracks.reduce(
      (acc, t) => acc + (parseFloat(t.time) || 0),
      0,
    );
    if (totalSec > 0) {
      const h = Math.floor(totalSec / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      playlistDuration = h > 0 ? `${h} hr ${m} min` : `${m} min`;
    } else {
      playlistDuration = "";
    }

    const formats = new Set();
    tracks.forEach((t) => {
      if (t.qualityBadge) formats.add(t.qualityBadge.split(" ")[0]);
    });
    playlistQuality =
      formats.size === 1
        ? tracks[0].qualityBadge
        : formats.size > 1
          ? "Mixed"
          : "";
  }

  function openPlaylist(playlist) {
    navigateTo("details", playlist);
  }
  function handleHeaderPlayAll() {
    pressedPlayAll = true;
    MPD.playPlaylistContext(currentView.data.name, 0);
  }
  function playTrack(index) {
    if (!isEditMode) MPD.playPlaylistContext(currentView.data.name, index);
  }
  function addToQueue() {
    if ($activePlaylistTracks.length > 0) {
      const safeName = currentView.data.name.replace(/"/g, '\\"');
      MPD.runMpdRequest(`load "${safeName}"`);
      pressedAddToQueue = true;
      setTimeout(() => {
        pressedAddToQueue = false;
      }, 2000);
    }
  }
  function toggleEditMode() {
    isEditMode = !isEditMode;
  }
  function handleRemoveTrack(index) {
    const playlistName = currentView.data.name;
    const tracks = $activePlaylistTracks;
    tracks.splice(index, 1);
    activePlaylistTracks.set(tracks);
    MPD.removeFromPlaylist(playlistName, index);
    calculateMeta(tracks);
  }
  function handleMoveTrack(fromIndex, toIndex) {
    MPD.movePlaylistTrack(currentView.data.name, fromIndex, toIndex);
  }
  $: isFavPlaylist = currentView?.data?.name === "Favorites";
</script>

<div class="view-container" class:scrollable={!isDetailsView}>
  {#if isDetailsView}
    <BaseList
      itemsStore={activePlaylistTracks}
      isLoading={$isLoadingTracks}
      {isEditMode}
      emptyText="This playlist is empty."
      onMoveItem={handleMoveTrack}
    >
      <div slot="header" class="content-padded">
        <div class="view-header">
          <div
            class="header-art"
            style="background: {isFavPlaylist
              ? 'linear-gradient(135deg, hsl(348, 95%, 58%), hsl(348, 90%, 40%))'
              : currentView.data.color || 'var(--c-bg-placeholder)'};"
          >
            <div class="header-icon-wrap">
              {@html isFavPlaylist ? ICONS.HEART_FILLED : ICONS.PLAYLISTS}
            </div>
          </div>

          <div class="header-info">
            <div class="header-text-group">
              <div class="header-label">Playlist</div>
              <h1 class="header-title" title={currentView.data.name}>
                {currentView.data.name}
              </h1>

              <div class="meta-badges">
                {#if $isLoadingTracks}
                  <span class="meta-tag">Loading...</span>
                {:else}
                  <span class="meta-tag">
                    {$activePlaylistTracks.length} tracks
                  </span>
                  {#if playlistDuration}
                    <span class="meta-tag">{playlistDuration}</span>
                  {/if}
                  {#if playlistQuality}
                    <span class="meta-tag quality">{playlistQuality}</span>
                  {/if}
                {/if}
              </div>
            </div>

            <div class="header-actions">
              <button
                class="btn-primary"
                on:click={handleHeaderPlayAll}
                disabled={pressedPlayAll}
              >
                {pressedPlayAll ? "Playing..." : "Play All"}
              </button>
              <button
                class="btn-secondary"
                on:click={addToQueue}
                disabled={pressedAddToQueue}
              >
                {pressedAddToQueue ? "Added" : "To Queue"}
              </button>
              <button
                class="btn-action"
                class:active={isEditMode}
                title="Edit"
                on:click={toggleEditMode}
              >
                {@html isEditMode ? ICONS.ACCEPT : ICONS.EDIT}
              </button>
            </div>
          </div>
        </div>
      </div>

      <div slot="row" let:item let:index let:startDrag>
        <TrackRow
          track={item}
          {index}
          isEditable={isEditMode}
          on:play={() => playTrack(index)}
          on:remove={() => handleRemoveTrack(index)}
          on:startdrag={startDrag}
        />
      </div>
    </BaseList>
  {:else if $isLoadingPlaylists}
    <div class="content-padded">
      <div class="music-grid">
        {#each Array(8) as _}
          <div class="music-card">
            <Skeleton
              width="100%"
              style="aspect-ratio: 1; border-radius: 12px; margin-bottom: 12px;"
            />
            <Skeleton width="60%" height="16px" />
          </div>
        {/each}
      </div>
    </div>
  {:else}
    <div class="content-padded">
      <div class="music-grid">
        <div class="music-card">
          <div class="card-img-container dashed-cover">
            <div class="icon-wrap" style="color: var(--c-icon-idle);">
              {@html ICONS.ADD}
            </div>
          </div>
          <div class="card-title">New Playlist</div>
        </div>
        {#each $playlists as playlist}
          {@const isFav = playlist.name === "Favorites"}
          <div class="music-card" on:click={() => openPlaylist(playlist)}>
            <div
              class="card-img-container"
              style="background: {playlist.color};"
            >
              <div class="icon-wrap">
                {@html isFav ? ICONS.HEART_FILLED : ICONS.PLAYLISTS}
              </div>
              <div class="play-overlay">
                <span style="width: 48px; color:#fff">{@html ICONS.PLAY}</span>
              </div>
            </div>
            <div class="card-title text-ellipsis">{playlist.name}</div>
            <div class="card-sub text-ellipsis">
              {playlist.lastModified
                ? new Date(playlist.lastModified).toLocaleDateString()
                : "Playlist"}
            </div>
          </div>
        {/each}
      </div>
    </div>
  {/if}
</div>

<style>
  @import "./MusicViews.css";

  .dashed-cover {
    background: transparent !important;
    border: 2px dashed var(--c-border-dashed);
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .dashed-cover:hover {
    border-color: var(--c-text-primary);
  }

  .icon-wrap {
    width: 30%;
    height: 30%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(255, 255, 255, 0.9);
  }
  .icon-wrap :global(svg) {
    width: 100%;
    height: 100%;
  }
</style>

=== ./components/views/BaseList.svelte ===
<script>
  import { onDestroy, onMount, tick } from "svelte";
  import { fade } from "svelte/transition";
  import Skeleton from "../Skeleton.svelte";
  import { createPlaylistDrag } from "../../lib/playlistDrag";

  import {
    navigationStack,
    activeMenuTab,
    saveScrollPosition,
    getScrollPosition,
  } from "../../lib/store";

  export let itemsStore;
  export let isEditMode = false;
  export let isLoading = false;
  export let emptyText = "List is empty";

  // Event callback for item reordering (fromIndex, toIndex)
  export let onMoveItem = (from, to) => {};

  // --- SCROLL RESTORATION LOGIC ---
  let scrollKey = "";
  let savedScrollTop = 0;
  let isRestored = false;

  // Формируем уникальный ключ для текущего экрана (например "albums_by_artist_Pink Floyd")
  $: {
    const stack = $navigationStack;
    const current = stack[stack.length - 1];
    const tab = $activeMenuTab;

    if (current && current.view === "root") {
      scrollKey = `root_${tab}`;
    } else if (current) {
      const dataName = current.data
        ? current.data.name || current.data
        : "unknown";
      scrollKey = `${current.view}_${dataName}`;
    }
  }

  // 1. При монтировании пытаемся получить позицию
  onMount(async () => {
    savedScrollTop = getScrollPosition(scrollKey);
    // Пробуем восстановить сразу, если данные уже есть
    if (!isLoading && savedScrollTop > 0 && dragEngine.refs.scrollContainer) {
      await tick();
      dragEngine.refs.scrollContainer.scrollTop = savedScrollTop;
      isRestored = true;
    }
  });

  // 2. Если данные загрузились позже, восстанавливаем после isLoading = false
  $: if (
    !isLoading &&
    !isRestored &&
    savedScrollTop > 0 &&
    dragEngine.refs.scrollContainer
  ) {
    restoreScrollAsync();
  }

  async function restoreScrollAsync() {
    await tick();
    if (dragEngine.refs.scrollContainer) {
      dragEngine.refs.scrollContainer.scrollTop = savedScrollTop;
      isRestored = true;
    }
  }

  // 3. Сохраняем позицию при уничтожении компонента (переход на другой view)
  onDestroy(() => {
    dragEngine.cancelDrag();
    if (dragEngine.refs.scrollContainer) {
      saveScrollPosition(scrollKey, dragEngine.refs.scrollContainer.scrollTop);
    }
  });

  // --- DRAG AND DROP LOGIC ---
  const dragEngine = createPlaylistDrag({
    tracksStore: itemsStore,
    onMoveTrack: (fromIndex, toIndex) => {
      onMoveItem(fromIndex, toIndex);
    },
  });

  const {
    isDragging,
    isDropping,
    isReordering,
    draggingIndex,
    hoverIndex,
    justDroppedIndex,
    draggedItemData,
    ghostCoords,
    refs,
  } = dragEngine;

  function startDrag(event, index, item) {
    if (!isEditMode) return;
    dragEngine.onDragInit(event, index, item);
  }
</script>

<svelte:window
  on:mousemove={dragEngine.onPointerMove}
  on:mouseup={dragEngine.onPointerUp}
  on:touchmove|nonpassive={dragEngine.onPointerMove}
  on:touchend={dragEngine.onPointerUp}
  on:touchcancel={dragEngine.onPointerUp}
/>

<div
  class="base-list-scroll-container"
  class:dragging={$isDragging}
  bind:this={refs.scrollContainer}
>
  {#if ($isDragging || $isDropping) && $draggedItemData}
    <div
      class="floating-item"
      class:dropping={$isDropping}
      style="
            top: {$ghostCoords.y - $ghostCoords.grabOffsetY}px; 
            left: {$ghostCoords.x - $ghostCoords.grabOffsetX}px;
            width: {$ghostCoords.width}px; 
            height: {$ghostCoords.height}px;
        "
    >
      <div style="pointer-events: none; width: 100%; height: 100%;">
        <slot
          name="row"
          item={$draggedItemData}
          index={$draggingIndex}
          isGhost={true}
          startDrag={() => {}}
        />
      </div>
    </div>
  {/if}

  <div
    class="list-body"
    bind:this={refs.listBodyContainer}
    in:fade={{ duration: 200 }}
  >
    <slot name="header"></slot>

    {#if isLoading}
      <div class="skeletons-wrapper">
        {#each Array(6) as _}
          <div style="padding: 10px 0;">
            <Skeleton width="100%" height="50px" />
          </div>
        {/each}
      </div>
    {:else}
      {#each $itemsStore as item, i (item._uid || i)}
        <div
          class="row-wrapper"
          class:ghost-placeholder={$draggingIndex === i &&
            ($isDragging || $isDropping)}
          class:just-dropped={$justDroppedIndex === i}
          class:no-transition={$isReordering}
          style={dragEngine.getRowStyle(
            i,
            $isDragging,
            $isDropping,
            $draggingIndex,
            $hoverIndex,
            $isReordering,
          )}
        >
          <slot
            name="row"
            {item}
            index={i}
            isGhost={false}
            startDrag={(e) => startDrag(e, i, item)}
          />
        </div>
      {/each}

      {#if $itemsStore.length === 0}
        <div class="content-padded" style="text-align: center; opacity: 0.5;">
          {emptyText}
        </div>
      {/if}
    {/if}
  </div>
</div>

<style>
  @import "./MusicViews.css";

  .skeletons-wrapper {
    padding: 0 32px;
  }
  @media (max-width: 768px) {
    .skeletons-wrapper {
      padding: 0 16px;
    }
  }
</style>

=== ./components/views/QueueView.svelte ===
<script>
  import { queue } from "../../lib/store";
  import { PlayerActions } from "../../lib/mpd/player";
  import * as MPD from "../../lib/mpd";
  import { ICONS } from "../../lib/icons";

  import TrackRow from "../TrackRow.svelte";
  import BaseList from "./BaseList.svelte";

  let isEditMode = false;
  let queueDuration = "";

  $: if ($queue.length >= 0) {
    const totalSec = $queue.reduce(
      (acc, t) => acc + (parseFloat(t.time) || 0),
      0,
    );
    if (totalSec > 0) {
      const h = Math.floor(totalSec / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      if (h > 0) queueDuration = `${h} hr ${m} min`;
      else queueDuration = `${m} min`;
    } else {
      queueDuration = "";
    }
  }

  function toggleEditMode() {
    isEditMode = !isEditMode;
  }

  function playTrack(pos) {
    if (isEditMode) return;
    MPD.runMpdRequest(`play ${pos}`);
  }

  function handleRemove(index) {
    PlayerActions.removeFromQueue(index);
  }

  async function handleSaveQueue() {
    const name = prompt("Enter playlist name:");
    if (name) {
      await PlayerActions.saveQueue(name);
      MPD.loadPlaylists();
    }
  }

  function handleMoveTrack(fromIndex, toIndex) {
    PlayerActions.moveTrack(fromIndex, toIndex);
  }
</script>

<div class="view-container">
  <BaseList
    itemsStore={queue}
    {isEditMode}
    emptyText="Queue is empty"
    onMoveItem={handleMoveTrack}
  >
    <div slot="header" class="content-padded">
      <div class="view-header">
        <div class="header-info queue-header-layout">
          <div class="header-text-group">
            <div class="header-label">Playing Next</div>
            <h1 class="header-title">Current Queue</h1>

            <div class="meta-badges">
              <span class="meta-tag">{$queue.length} tracks</span>
              {#if queueDuration}
                <span class="meta-tag">{queueDuration}</span>
              {/if}
            </div>
          </div>

          <div class="header-actions">
            <button
              class="btn-action"
              on:click={handleSaveQueue}
              title="Save Queue"
            >
              {@html ICONS.SAVE}
            </button>

            <button
              class="btn-action"
              class:active={isEditMode}
              on:click={toggleEditMode}
              title={isEditMode ? "Finish Editing" : "Edit Queue"}
            >
              {@html isEditMode ? ICONS.ACCEPT : ICONS.EDIT}
            </button>
          </div>
        </div>
      </div>
    </div>

    <div slot="row" let:item let:index let:startDrag>
      <TrackRow
        track={item}
        {index}
        isEditable={isEditMode}
        on:play={() => playTrack(index)}
        on:remove={() => handleRemove(index)}
        on:startdrag={startDrag}
      />
    </div>
  </BaseList>
</div>

<style>
  @import "./MusicViews.css";

  /* Override for Queue: Place items in Row on desktop if enough space, or keep stacked but ensure buttons align left */
  .queue-header-layout {
    justify-content: flex-end;
  }

  /* Ensure actions align left here per request */
  .header-actions {
    margin-top: 16px;
    justify-content: flex-start;
  }
</style>

=== ./components/views/LibraryView.svelte ===
<script>
  import { writable } from "svelte/store";
  import { db } from "../../lib/db";
  import {
    navigationStack,
    navigateTo,
    getTrackCoverUrl,
    getTrackThumbUrl,
  } from "../../lib/store";
  import TrackRow from "../TrackRow.svelte";
  import Skeleton from "../Skeleton.svelte";
  import * as MPD from "../../lib/mpd";
  import { ICONS } from "../../lib/icons";
  import ImageLoader from "../ImageLoader.svelte";
  import BaseList from "./BaseList.svelte";

  export let activeCategory = "artists";

  const itemsStore = writable([]);
  let isLoading = true;
  let searchTerm = "";

  // Sorting State
  let sortOption = "name";
  let isSortMenuOpen = false;

  const SORT_OPTIONS = [
    { id: "name", label: "A-Z" },
    { id: "artist", label: "Artist" },
    { id: "year", label: "Oldest" },
    { id: "year_desc", label: "Newest" },
  ];

  let pressedPlayAll = false;
  let pressedAddToQueue = false;

  let headerItem = null;
  let albumTotalDuration = "";
  let albumQuality = "";
  let trackCount = 0;
  let albumYear = "";

  // === ЗАЩИТА ОТ ГОНКИ ЗАПРОСОВ ===
  let lastRequestId = 0;

  $: currentSortIcon =
    sortOption === "year_desc" ? ICONS.SORT_ASC : ICONS.SORT_DESC;

  $: filteredItems = sortItems(
    $itemsStore.filter((item) => {
      if (!searchTerm) return true;
      const term = searchTerm.toLowerCase();
      return (
        item.displayName.toLowerCase().includes(term) ||
        (item.artist && item.artist.toLowerCase().includes(term))
      );
    }),
    sortOption,
  );

  $: currentView = $navigationStack[$navigationStack.length - 1];

  $: if (activeCategory) {
    searchTerm = "";
    if (activeCategory === "albums") sortOption = "name";
    else sortOption = "name";
  }

  // Реактивная загрузка контента
  $: loadContent(activeCategory, currentView);

  $: if (currentView) {
    pressedPlayAll = false;
    pressedAddToQueue = false;
    isSortMenuOpen = false;
  }

  function toggleSortMenu() {
    isSortMenuOpen = !isSortMenuOpen;
  }

  function selectSort(optionId) {
    sortOption = optionId;
    isSortMenuOpen = false;
  }

  function sortItems(items, option) {
    if (!items || items.length === 0) return [];

    const sorted = [...items].sort((a, b) => {
      switch (option) {
        case "name":
          return a.displayName.localeCompare(b.displayName, undefined, {
            sensitivity: "base",
          });

        case "artist":
          const artA = a.artist || "";
          const artB = b.artist || "";
          const cmp = artA.localeCompare(artB, undefined, {
            sensitivity: "base",
          });
          if (cmp !== 0) return cmp;
          return (parseInt(a.year) || 0) - (parseInt(b.year) || 0);

        case "year":
          return (parseInt(a.year) || 0) - (parseInt(b.year) || 0);

        case "year_desc":
          return (parseInt(b.year) || 0) - (parseInt(a.year) || 0);

        default:
          return 0;
      }
    });

    if (option === "artist") {
      const grouped = [];
      let lastArtist = null;

      sorted.forEach((item) => {
        const currentArtist = item.artist || "Unknown Artist";
        if (currentArtist !== lastArtist) {
          grouped.push({
            _uid: `header-${currentArtist}`,
            isHeader: true,
            title: currentArtist,
          });
          lastArtist = currentArtist;
        }
        grouped.push(item);
      });
      return grouped;
    }

    return sorted;
  }

  async function loadContent(category, viewState) {
    if (!viewState) return;
    const requestId = ++lastRequestId;

    isLoading = true;
    itemsStore.set([]);

    headerItem = viewState.data;
    albumTotalDuration = "";
    albumQuality = "";
    albumYear = "";
    trackCount = 0;

    try {
      let data = [];

      if (viewState.view === "root") {
        data =
          category === "artists" ? await db.getArtists() : await db.getAlbums();
      } else if (viewState.view === "albums_by_artist") {
        const artistName = viewState.data.name || viewState.data;
        data = await db.getArtistAlbums(artistName);
        sortOption = "year";
      } else if (viewState.view === "tracks_by_album") {
        const albumName = viewState.data.name || viewState.data;
        const artistName = viewState.data.artist;
        data = await db.getAlbumTracks(albumName, artistName);
      }

      if (requestId !== lastRequestId) return;

      const enriched = data.map((item, idx) => {
        const isString = typeof item === "string";
        const obj = isString ? { name: item } : item;

        let yStr = String(obj.year || "");
        if (yStr.length > 4) yStr = yStr.substring(0, 4);

        return {
          ...obj,
          displayName: obj.name || obj.title || obj.artist || "Unknown",
          thumbFile: obj.file || null,
          year: yStr,
          _uid: (obj.file || obj.name || idx) + category + viewState.view,
        };
      });

      itemsStore.set(enriched);

      if (viewState.view === "tracks_by_album" && enriched.length > 0) {
        headerItem = enriched[0];
        trackCount = enriched.length;
        albumYear = enriched[0].year;

        const totalSec = enriched.reduce((acc, t) => acc + (t.time || 0), 0);
        if (totalSec > 0) {
          const h = Math.floor(totalSec / 3600);
          const m = Math.floor((totalSec % 3600) / 60);
          albumTotalDuration = h > 0 ? `${h} hr ${m} min` : `${m} min`;
        }

        if (enriched[0].qualityBadge) {
          albumQuality = enriched[0].qualityBadge;
        }
      }
    } catch (e) {
      if (requestId === lastRequestId) {
        console.error(e);
        itemsStore.set([]);
      }
    } finally {
      if (requestId === lastRequestId) {
        isLoading = false;
      }
    }
  }

  function handleItemClick(item) {
    if (currentView.view === "root") {
      if (activeCategory === "artists") {
        navigateTo("albums_by_artist", item);
      } else {
        navigateTo("tracks_by_album", item);
      }
    } else if (currentView.view === "albums_by_artist") {
      navigateTo("tracks_by_album", item);
    }
  }

  function handlePlayAll() {
    const items = $itemsStore;
    if (items.length > 0) {
      pressedPlayAll = true;
      MPD.playAllTracks(items);
    }
  }

  function handleAddToQueue() {
    const items = $itemsStore;
    if (items.length > 0) {
      pressedAddToQueue = true;
      MPD.addAllToQueue(items);
      setTimeout(() => {
        pressedAddToQueue = false;
      }, 2000);
    }
  }
</script>

<div
  class="view-container"
  class:scrollable={currentView?.view !== "tracks_by_album"}
>
  {#if currentView?.view === "tracks_by_album"}
    <BaseList
      {itemsStore}
      {isLoading}
      isEditMode={false}
      emptyText="No tracks found"
    >
      <div slot="header" class="content-padded">
        <div class="view-header">
          <div class="header-art">
            <ImageLoader
              src={getTrackCoverUrl(headerItem)}
              alt="Art"
              radius="var(--radius-lg)"
            >
              <div slot="fallback" class="icon-fallback">
                {@html ICONS.ALBUMS}
              </div>
            </ImageLoader>
          </div>

          <div class="header-info">
            <div class="header-text-group">
              <div class="header-label">
                {currentView.view === "albums_by_artist" ? "Artist" : "Album"}
              </div>
              <h1
                class="header-title"
                title={currentView.data.name || currentView.data.displayName}
              >
                {currentView.data.name ||
                  currentView.data.displayName ||
                  "Unknown"}
              </h1>

              {#if headerItem && headerItem.artist}
                <div class="header-sub">
                  {headerItem.artist}
                </div>
              {/if}

              <div class="meta-badges">
                {#if albumYear && albumYear !== "0"}
                  <span class="meta-tag">{albumYear}</span>
                {/if}
                {#if trackCount > 0}
                  <span class="meta-tag">{trackCount} tracks</span>
                {/if}
                {#if albumTotalDuration}
                  <span class="meta-tag">{albumTotalDuration}</span>
                {/if}
                {#if albumQuality}
                  <span class="meta-tag quality">{albumQuality}</span>
                {/if}
              </div>
            </div>

            <div class="header-actions">
              <button
                class="btn-primary"
                on:click={handlePlayAll}
                disabled={pressedPlayAll}
              >
                {pressedPlayAll ? "Playing..." : "Play All"}
              </button>

              <button
                class="btn-secondary"
                on:click={handleAddToQueue}
                disabled={pressedAddToQueue}
              >
                {pressedAddToQueue ? "Added" : "To Queue"}
              </button>
            </div>
          </div>
        </div>
      </div>

      <div slot="row" let:item let:index>
        <TrackRow
          track={item}
          {index}
          isEditable={false}
          on:play={() => MPD.playTrackOptimistic(item)}
        />
      </div>
    </BaseList>
  {:else}
    <div class="content-padded">
      <div class="search-input-container">
        <span class="search-icon">
          {@html ICONS.SEARCH}
        </span>
        <input
          type="text"
          placeholder="Filter {activeCategory}..."
          bind:value={searchTerm}
        />

        {#if activeCategory === "albums" || currentView.view === "albums_by_artist"}
          <div class="sort-wrapper">
            <button class="sort-trigger" on:click={toggleSortMenu}>
              <span>{SORT_OPTIONS.find((o) => o.id === sortOption)?.label}</span
              >
              <span class="sort-trigger-icon">{@html currentSortIcon}</span>
            </button>

            {#if isSortMenuOpen}
              <div class="sort-backdrop" on:click={toggleSortMenu}></div>
              <div class="sort-menu">
                {#each SORT_OPTIONS as opt}
                  <button
                    class="sort-item"
                    class:selected={sortOption === opt.id}
                    on:click={() => selectSort(opt.id)}
                  >
                    {opt.label}
                  </button>
                {/each}
              </div>
            {/if}
          </div>
        {/if}
      </div>

      {#if isLoading}
        <div class="music-grid">
          {#each Array(12) as _}
            <div class="music-card">
              <Skeleton
                width="100%"
                style="aspect-ratio:1; border-radius:12px; margin-bottom:12px;"
              />
              <Skeleton width="80%" height="16px" />
            </div>
          {/each}
        </div>
      {:else}
        <div class="music-grid">
          {#each filteredItems as item (item._uid)}
            {#if item.isHeader}
              <div class="group-header header-label">
                {item.title}
              </div>
            {:else}
              <div
                class="music-card"
                on:click={() => handleItemClick(item)}
                role="button"
                tabindex="0"
                on:keypress={(e) => e.key === "Enter" && handleItemClick(item)}
              >
                <div class="card-img-container">
                  <ImageLoader
                    src={getTrackThumbUrl(item, "md")}
                    alt={item.displayName}
                    radius="var(--radius-md)"
                  >
                    <div slot="fallback" class="icon-fallback">
                      {#if activeCategory === "artists"}
                        {@html ICONS.ARTISTS}
                      {:else}
                        {@html ICONS.ALBUMS}
                      {/if}
                    </div>
                  </ImageLoader>

                  <div class="play-overlay">
                    <span style="width:48px; color:#fff"
                      >{@html ICONS.PLAY}</span
                    >
                  </div>
                </div>

                <div class="card-title text-ellipsis">{item.displayName}</div>
                <div class="card-sub-row">
                  {#if item.artist}
                    <div class="card-sub text-ellipsis">{item.artist}</div>
                  {/if}

                  {#if item.year && item.year !== "0"}
                    <div class="card-year">{item.year}</div>
                  {/if}

                  {#if item.qualityBadge}
                    <div class="card-year quality">
                      {item.qualityBadge.split(" ")[0]}
                    </div>
                  {/if}
                </div>
              </div>
            {/if}
          {:else}
            <div class="empty-text">No results found</div>
          {/each}
        </div>
      {/if}
    </div>
  {/if}
</div>

<style>
  @import "./MusicViews.css";
  @import "../../styles/SortMenu.css";

  .sort-wrapper {
    position: relative;
    margin-left: 8px;
    height: 100%;
    display: flex;
    align-items: center;
  }

  .sort-trigger {
    display: flex;
    align-items: center;
    gap: 6px;
    background: transparent;
    border: none;
    color: var(--c-text-secondary);
    padding: 0 8px;
    font-size: 13px;
    font-weight: 600;
    height: 100%;
    cursor: pointer;
    transition: color 0.2s;
  }

  .sort-trigger:hover {
    color: var(--c-text-primary);
  }

  .sort-trigger-icon {
    display: flex;
    align-items: center;
    opacity: 0.7;
  }
  .sort-trigger-icon :global(svg) {
    width: 16px;
    height: 16px;
  }
</style>

=== ./components/SideMenu.svelte ===
<script>
  import { createEventDispatcher } from "svelte";
  import { fade } from "svelte/transition";
  import logo from "../assets/wave-logo.svg";
  import { ICONS } from "../lib/icons";
  import {
    activeMenuTab,
    isSyncingLibrary,
    isSidebarCollapsed,
  } from "../lib/store";
  import { ApiActions } from "../lib/api";
  import { CONFIG } from "../config";

  export let isOpen = false;
  const dispatch = createEventDispatcher();

  let touchStartX = 0;
  let touchCurrentX = 0;
  let isSwiping = false;

  const MENU_ITEMS = [
    { id: "queue", label: "Queue", icon: ICONS.MENU },
    { id: "favorites", label: "Favorites", icon: ICONS.HEART },
    { id: "artists", label: "Artists", icon: ICONS.ARTISTS },
    { id: "albums", label: "Albums", icon: ICONS.ALBUMS },
    { id: "playlists", label: "Playlists", icon: ICONS.PLAYLISTS },
    { id: "radio", label: "Radio", icon: ICONS.RADIO },
  ];

  let ipAddress = CONFIG.MOODE_IP;

  function switchTab(id) {
    window.location.hash = `/${id}`;
    dispatch("close");
  }

  async function handleSync() {
    if ($isSyncingLibrary) return;
    await ApiActions.syncLibrary();
    window.location.hash = "/artists";
  }

  function toggleCollapse() {
    isSidebarCollapsed.update((v) => !v);
  }

  function handleTouchStart(e) {
    if (!isOpen) return;
    touchStartX = e.touches[0].clientX;
    touchCurrentX = touchStartX;
    isSwiping = true;
  }

  function handleTouchMove(e) {
    if (!isSwiping) return;
    touchCurrentX = e.touches[0].clientX;
  }

  function handleTouchEnd() {
    if (!isSwiping) return;
    if (touchCurrentX - touchStartX < -70) dispatch("close");
    isSwiping = false;
    touchStartX = 0;
    touchCurrentX = 0;
  }

  $: translateX = isSwiping ? Math.min(0, touchCurrentX - touchStartX) : 0;
</script>

{#if isOpen}
  <div
    class="backdrop"
    on:click={() => dispatch("close")}
    transition:fade={{ duration: 200 }}
  ></div>
{/if}

<aside
  class="side-menu"
  class:mobile-open={isOpen}
  class:collapsed={$isSidebarCollapsed}
  style:transform={isOpen ? `translateX(${translateX}px)` : ""}
  style:transition={isSwiping
    ? "none"
    : "width 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.3s ease"}
  on:touchstart={handleTouchStart}
  on:touchmove={handleTouchMove}
  on:touchend={handleTouchEnd}
>
  <div class="header">
    <div class="header-inner">
      <button
        class="collapse-btn"
        on:click={toggleCollapse}
        title={$isSidebarCollapsed ? "Expand" : "Collapse"}
      >
        <div
          class="chevron"
          style="transform: rotate({$isSidebarCollapsed ? '180deg' : '0deg'})"
        >
          {@html ICONS.BACK}
        </div>
      </button>

      <div class="logo-wrapper" class:hidden={$isSidebarCollapsed}>
        <img src={logo} alt="Logo" class="logo" />
      </div>
    </div>

    <button class="btn-icon mobile-close" on:click={() => dispatch("close")}>
      {@html ICONS.CLOSE}
    </button>
  </div>

  <div class="scroll-area custom-scrollbar">
    <nav>
      {#each MENU_ITEMS as item}
        <button
          class="nav-item"
          class:active={$activeMenuTab === item.id}
          title={item.label}
          on:click={() => switchTab(item.id)}
        >
          <span class="icon">{@html item.icon}</span>
          <span class="label-text" class:hidden={$isSidebarCollapsed}
            >{item.label}</span
          >
        </button>
      {/each}

      <button
        class="nav-item"
        class:active={$activeMenuTab === "search"}
        title="Search"
        on:click={() => switchTab("search")}
      >
        <span class="icon">{@html ICONS.SEARCH}</span>
        <span class="label-text" class:hidden={$isSidebarCollapsed}>Search</span
        >
      </button>

      <div class="sep"></div>

      <button
        class="nav-item sync"
        title="Update Library"
        disabled={$isSyncingLibrary}
        on:click={handleSync}
      >
        <span class="icon" class:spin={$isSyncingLibrary}
          >{@html ICONS.SYNC}</span
        >
        <span class="label-text" class:hidden={$isSidebarCollapsed}
          >{$isSyncingLibrary ? "Syncing..." : "Update Library"}</span
        >
      </button>

      <div class="settings-wrapper" class:hidden={$isSidebarCollapsed}>
        <div class="settings">
          <div class="row">
            <input
              type="text"
              bind:value={ipAddress}
              placeholder="192.168..."
            />
            <button
              class="save"
              on:click={() => {
                CONFIG.setMoodeIp(ipAddress);
                location.reload();
              }}>OK</button
            >
          </div>
        </div>
      </div>
    </nav>

    <div class="footer">
      <div class="footer-text" class:hidden={$isSidebarCollapsed}>
        Moode WaveUI
      </div>
    </div>
  </div>
</aside>

<style>
  .side-menu {
    width: 250px;
    height: 100%;
    background: var(--c-bg-sidebar);
    border-right: 1px solid var(--c-border);
    display: flex;
    flex-direction: column;
    z-index: var(--z-modal);
    flex-shrink: 0;
    overflow: hidden;
    transition: width 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .side-menu.collapsed {
    width: 80px;
  }

  .scroll-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }

  .header {
    height: 80px;
    display: flex;
    align-items: center;
    flex-shrink: 0;
    padding: 0 10px;
    position: relative;
  }

  .header-inner {
    display: flex;
    align-items: center;
    width: 100%;
    height: 100%;
    position: relative;
  }

  .collapse-btn {
    background: transparent;
    border: none;
    color: var(--c-text-muted);
    width: 40px;
    height: 40px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    flex-shrink: 0;
    transition:
      color 0.2s,
      background 0.2s;
    /* Position absolutely to keep it fixed while menu shrinks */
    position: absolute;
    left: 8px;
    z-index: 10;
  }
  .collapsed .collapse-btn {
    left: 10px;
  }

  .collapse-btn:hover {
    color: var(--c-text-primary);
    background: var(--c-surface-hover);
  }

  .chevron {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  .chevron :global(svg) {
    width: 100%;
    height: 100%;
  }

  .logo-wrapper {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition:
      opacity 0.2s ease,
      transform 0.2s ease;
    opacity: 1;
    transform: translateX(0);
  }
  .logo-wrapper.hidden {
    opacity: 0;
    transform: translateX(-10px);
    pointer-events: none;
  }

  .logo {
    height: 32px;
    filter: drop-shadow(0 0 10px var(--c-shadow-glow-accent));
    display: block;
  }

  .mobile-close {
    display: none;
    position: absolute;
    right: 15px;
    color: var(--c-text-primary);
    z-index: 5;
  }

  nav {
    padding: 10px 0;
    display: flex;
    flex-direction: column;
    gap: 4px;
    flex: 1;
  }

  .nav-item {
    display: flex;
    align-items: center;
    width: auto;
    height: 48px;
    color: var(--c-text-muted);
    font-size: 15px;
    font-weight: 600;
    background: transparent;
    border: none;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;

    border-radius: 12px;
    margin: 2px 12px;

    padding: 0 16px;

    transition:
      background 0.2s,
      color 0.2s;
  }
  .nav-item:hover {
    background: var(--c-surface-hover);
    color: var(--c-text-primary);
  }
  .nav-item.active {
    background: var(--c-accent);
    color: var(--c-text-primary);
  }

  .icon {
    margin-right: 16px;
    display: flex;
    flex-shrink: 0;
    justify-content: center;
    align-items: center;
    width: 24px;
    height: 24px;
  }
  .icon :global(svg) {
    width: 24px;
    height: 24px;
  }

  .label-text {
    opacity: 1;
    transition: opacity 0.2s ease;
  }
  .label-text.hidden {
    opacity: 0;
  }

  .sep {
    height: 1px;
    background: var(--c-border);
    margin: 10px 28px; /* Align separator with text start (12+16) */
    flex-shrink: 0;
    opacity: 0.5;
  }
  .spin {
    animation: rotate 2s linear infinite;
  }
  @keyframes rotate {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  .settings-wrapper {
    transition:
      opacity 0.2s ease,
      height 0.2s ease,
      margin 0.2s ease;
    opacity: 1;
    height: auto;
    overflow: hidden;
  }
  .settings-wrapper.hidden {
    opacity: 0;
    height: 0;
    pointer-events: none;
    margin: 0;
  }

  .settings {
    padding: 10px 16px 0;
    margin: 0 12px; /* Align with nav items */
  }

  .row {
    display: flex;
    gap: 8px;
  }

  input {
    flex: 1;
    background: var(--c-surface-input);
    border: 1px solid var(--c-border);
    color: var(--c-text-primary);
    padding: 8px;
    border-radius: 8px;
    outline: none;
    width: 100%;
    min-width: 0;
    font-size: 13px;
  }
  .save {
    background: var(--c-surface-button);
    border: 1px solid var(--c-border);
    color: var(--c-text-primary);
    padding: 0 10px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 700;
  }
  .save:hover {
    background: var(--c-surface-hover);
  }

  .footer {
    padding: 20px 0;
    text-align: center;
    margin-top: auto;
  }
  .footer-text {
    font-size: 10px;
    color: var(--c-text-muted);
    opacity: 0.5;
    transition: opacity 0.2s;
    white-space: nowrap;
  }
  .footer-text.hidden {
    opacity: 0;
  }

  .custom-scrollbar::-webkit-scrollbar {
    width: 4px;
  }
  .custom-scrollbar::-webkit-scrollbar-thumb {
    background: var(--c-border);
    border-radius: 2px;
  }
  .custom-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }

  @media (max-width: 768px) and (orientation: portrait) {
    .side-menu {
      position: fixed;
      left: 0;
      top: 0;
      height: 100dvh;
      width: 280px !important;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
    }
    .side-menu.mobile-open {
      transform: translateX(0);
    }
    .mobile-close {
      display: flex;
    }
    .backdrop {
      position: fixed;
      inset: 0;
      background: var(--c-overlay-backdrop);
      z-index: 999;
      backdrop-filter: blur(4px);
    }

    /* Force FULL View elements visible */
    .collapse-btn {
      display: none;
    }
    .logo-wrapper.hidden {
      opacity: 1 !important;
      transform: none !important;
    }
    .label-text.hidden {
      opacity: 1 !important;
    }
    .settings-wrapper.hidden {
      opacity: 1 !important;
      height: auto !important;
      pointer-events: auto !important;
    }
    .footer-text.hidden {
      opacity: 0.5 !important;
    }
  }

  @media (max-height: 600px) and (orientation: landscape) {
    .side-menu {
      width: 200px;
    }
    .side-menu.collapsed {
      width: 80px;
    }
    .nav-item {
      padding: 0 12px;
      /* Re-calc center for 80px collapsed width in landscape */
      /* margin 12px -> 12 left. Center is 40. Icon half is 12. 
         Pad = 40 - 12 - 12 = 16px. Same math holds! */
      padding-left: 16px;
    }
    .settings {
      padding: 4px 0 0; /* Adjusted for tighter space */
    }
    .header {
      padding: 0 10px;
    }
    .collapse-btn {
      left: 8px;
    }
  }
</style>

=== ./components/PlaylistSelector.svelte ===
<script>
  import { fade, scale } from "svelte/transition";
  import {
    playlistSelector,
    closePlaylistSelector,
    playlists,
    showToast,
  } from "../lib/store";
  import { ICONS } from "../lib/icons";
  import { mpdClient } from "../lib/mpd/client";

  async function addTo(playlistName) {
    const track = $playlistSelector.track;
    if (!track) return;

    try {
      const safePl = playlistName.replace(/"/g, '\\"');
      const safeFile = track.file.replace(/"/g, '\\"');

      await mpdClient.send(`playlistadd "${safePl}" "${safeFile}"`);
      showToast(`Added to "${playlistName}"`, "success");
      closePlaylistSelector();
    } catch (e) {
      console.error(e);
      showToast("Failed to add to playlist", "error");
    }
  }
</script>

{#if $playlistSelector.isOpen}
  <div
    class="backdrop"
    on:click={closePlaylistSelector}
    transition:fade={{ duration: 150 }}
  >
    <div
      class="modal"
      transition:scale={{ start: 0.95, duration: 200 }}
      on:click|stopPropagation
    >
      <div class="header">
        <h3>Add to Playlist</h3>
        <button class="close-btn" on:click={closePlaylistSelector}>
          {@html ICONS.CLOSE}
        </button>
      </div>

      <div class="list">
        {#each $playlists as pl}
          {#if pl.name !== "Favorites"}
            <button class="pl-row" on:click={() => addTo(pl.name)}>
              <div class="pl-icon">{@html ICONS.PLAYLISTS}</div>
              <span>{pl.name}</span>
            </button>
          {/if}
        {/each}

        {#if $playlists.length <= 1}
          <div class="empty">No custom playlists created.</div>
        {/if}
      </div>
    </div>
  </div>
{/if}

<style>
  .backdrop {
    position: fixed;
    inset: 0;
    z-index: var(--z-modal);
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(2px);
    padding: 20px;
  }

  .modal {
    background: var(--c-bg-app);
    width: 100%;
    max-width: 400px;
    max-height: 70vh;
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    border: 1px solid var(--c-border);
  }

  .header {
    padding: 16px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--c-border);
  }
  h3 {
    margin: 0;
    color: var(--c-text-primary);
  }

  .close-btn {
    background: none;
    border: none;
    color: var(--c-text-muted);
    cursor: pointer;
    width: 24px;
    height: 24px;
    padding: 0;
  }
  .close-btn :global(svg) {
    width: 100%;
    height: 100%;
  }

  .list {
    overflow-y: auto;
    padding: 10px 0;
  }

  .pl-row {
    width: 100%;
    display: flex;
    align-items: center;
    padding: 12px 20px;
    background: none;
    border: none;
    color: var(--c-text-primary);
    text-align: left;
    font-size: 16px;
    cursor: pointer;
    transition: background 0.2s;
  }
  .pl-row:hover {
    background: var(--c-surface-hover);
  }

  .pl-icon {
    width: 24px;
    height: 24px;
    margin-right: 12px;
    color: var(--c-text-secondary);
  }
  .pl-icon :global(svg) {
    width: 100%;
    height: 100%;
  }

  .empty {
    padding: 20px;
    text-align: center;
    color: var(--c-text-muted);
  }
</style>

=== ./components/MiniPlayer.svelte ===
<script>
  import * as MPD from "../lib/mpd";
  import { ICONS } from "../lib/icons";
  import { LibraryActions } from "../lib/mpd/library";
  import {
    currentSong,
    status,
    isFullPlayerOpen,
    favorites,
    getTrackCoverUrl,
    stations,
    openContextMenu,
  } from "../lib/store.js";
  import { longpress } from "../lib/actions";
  import ImageLoader from "./ImageLoader.svelte";

  let isHoveringBar = false;
  let isDragging = false;
  let isDraggingVol = false;
  let dragProgress = 0;
  let progressBar;
  let volumeBar;

  const stop = (fn) => (e) => {
    e.stopPropagation();
    fn();
  };

  function formatTime(seconds) {
    if (isNaN(seconds) || seconds === null) return "0:00";
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${s < 10 ? "0" : ""}${s}`;
  }

  $: duration = $status.duration > 0 ? $status.duration : 1;
  $: elapsed = $status.elapsed || 0;
  $: isPlaying = $status.state === "play";
  $: isRadio = $currentSong.file?.startsWith("http");

  $: displayTitle = $currentSong.title || "Not Playing";
  $: displayArtist = $currentSong.stationName || $currentSong.artist || "Moode";
  $: isLiked = $currentSong.file && $favorites.has($currentSong.file);

  $: artSrc = getTrackCoverUrl(
    $currentSong,
    $stations,
    $currentSong.stationName,
  );

  $: pct = isRadio
    ? 0
    : isDragging
      ? dragProgress * 100
      : (elapsed / duration) * 100;
  $: smooth = isPlaying && !isDragging && !isRadio;

  $: qualityLabel = $status.bitrate
    ? `${$status.bitrate} kbps`
    : $status.format || "";

  function getPct(e, element) {
    const rect = element.getBoundingClientRect();
    return Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
  }

  function handleMouseDown(e) {
    if (isRadio) return;
    isDragging = true;
    dragProgress = getPct(e, progressBar);
    window.addEventListener("mousemove", onWinMove);
    window.addEventListener("mouseup", onWinUp);
  }

  function onWinMove(e) {
    if (isDragging) dragProgress = getPct(e, progressBar);
    if (isDraggingVol) {
      const vol = Math.round(getPct(e, volumeBar) * 100);
      MPD.setVolume(vol);
    }
  }

  function onWinUp() {
    if (isDragging && !isRadio) {
      MPD.seek(dragProgress * duration);
    }
    isDragging = false;
    isDraggingVol = false;
    window.removeEventListener("mousemove", onWinMove);
    window.removeEventListener("mouseup", onWinUp);
  }

  function handleVolDown(e) {
    isDraggingVol = true;
    const vol = Math.round(getPct(e, volumeBar) * 100);
    MPD.setVolume(vol);
    window.addEventListener("mousemove", onWinMove);
    window.addEventListener("mouseup", onWinUp);
  }

  $: currentMode = $status.repeat ? 2 : $status.random ? 1 : 0;

  function toggleMode() {
    const nextMode = (currentMode + 1) % 3;

    if (nextMode === 0) {
      if ($status.random) MPD.toggleRandom();
      if ($status.repeat) MPD.toggleRepeat();
    } else if (nextMode === 1) {
      if (!$status.random) MPD.toggleRandom();
      if ($status.repeat) MPD.toggleRepeat();
    } else if (nextMode === 2) {
      if ($status.random) MPD.toggleRandom();
      if (!$status.repeat) MPD.toggleRepeat();
    }
  }

  function handleContext(e) {
    e.stopPropagation();
    openContextMenu(e, $currentSong, { type: "general", source: "miniplayer" });
  }

  function handleLongPress(e) {
    openContextMenu(e.detail.originalEvent, $currentSong, {
      type: "general",
      source: "miniplayer",
    });
  }
</script>

{#if !$isFullPlayerOpen}
  <div
    class="dock"
    on:click={() => isFullPlayerOpen.set(true)}
    use:longpress={500}
    on:longpress={handleLongPress}
  >
    <div
      class="progress-shadow"
      style="width: {pct}%; transition: {smooth
        ? 'width 0.25s linear'
        : 'none'}"
    ></div>

    <div
      class="progress-bar"
      class:radio={isRadio}
      bind:this={progressBar}
      on:mouseenter={() => (isHoveringBar = true)}
      on:mouseleave={() => (isHoveringBar = false)}
      on:mousedown|stopPropagation={handleMouseDown}
      on:click|stopPropagation
    >
      <div class="rail"></div>
      <div
        class="fill"
        style="width: {pct}%; transition: {smooth
          ? 'width 0.25s linear'
          : 'none'}"
      >
        {#if !isRadio}<div class="knob"></div>{/if}
      </div>

      {#if (isHoveringBar || isDragging) && !isRadio}
        <div class="tooltip current" style="left: {pct}%">
          {isDragging
            ? formatTime(dragProgress * duration)
            : formatTime(elapsed)}
        </div>
      {/if}
    </div>

    <div class="grid">
      <div class="info">
        <div class="art">
          <ImageLoader src={artSrc} alt="art" radius="4px">
            <div slot="fallback" class="icon-fallback">
              {@html isRadio ? ICONS.RADIO : ICONS.ALBUMS}
            </div>
          </ImageLoader>
        </div>

        <div class="meta">
          <div class="title-row">
            <div class="title text-ellipsis" title={displayTitle}>
              {displayTitle}
            </div>
            <button class="btn-icon tiny-dots" on:click={handleContext}>
              {@html ICONS.DOTS}
            </button>
          </div>
          <div class="artist-row">
            <div class="artist text-ellipsis" title={displayArtist}>
              {displayArtist}
            </div>
            {#if qualityLabel}
              <span class="quality-badge">{qualityLabel}</span>
            {/if}
          </div>
        </div>
      </div>

      <div class="controls">
        <button
          class="btn-icon desktop"
          class:liked={isLiked}
          on:click={stop(() => LibraryActions.toggleFavorite($currentSong))}
        >
          {@html isLiked ? ICONS.HEART_FILLED : ICONS.HEART}
        </button>

        <button class="btn-icon" on:click={stop(() => MPD.nav("previous"))}>
          {@html ICONS.PREVIOUS}
        </button>

        <button class="play-btn flex-center" on:click={stop(MPD.togglePlay)}>
          {@html $status.state === "play" ? ICONS.PAUSE : ICONS.PLAY}
        </button>

        <button class="btn-icon" on:click={stop(() => MPD.nav("next"))}>
          {@html ICONS.NEXT}
        </button>

        {#if !isRadio}
          <button
            class="btn-icon desktop mode-btn"
            class:active={currentMode > 0}
            on:click={stop(toggleMode)}
          >
            {#if currentMode === 2}
              {@html ICONS.REPEAT}
            {:else}
              {@html ICONS.SHUFFLE}
            {/if}
            {#if currentMode > 0}
              <div class="dot"></div>
            {/if}
          </button>
        {/if}
      </div>

      <div class="volume desktop">
        <div class="vol-icon">{@html ICONS.VOLUME}</div>
        <div
          class="custom-slider"
          bind:this={volumeBar}
          on:mousedown|stopPropagation={handleVolDown}
          on:click|stopPropagation
        >
          <div class="slider-bg">
            <div class="slider-fill" style="width: {$status.volume}%"></div>
            <div class="slider-knob" style="left: {$status.volume}%"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
{/if}

<style>
  .dock {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: var(--mini-player-height);
    background: var(--c-bg-glass);
    border-top: 1px solid var(--c-border-dim);
    z-index: var(--z-dock);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    cursor: pointer;
    user-select: none;
    transition: background 0.3s;
  }
  .dock:hover {
    background: #181818;
  }

  /* Progress Bar */
  .progress-shadow {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    background: var(--c-surface-button);
    z-index: 1;
    pointer-events: none;
    opacity: 0.1;
  }

  .progress-bar {
    position: absolute;
    top: -6px;
    left: 0;
    width: 100%;
    height: 14px;
    z-index: 10;
    cursor: pointer;
    display: flex;
    align-items: center;
  }
  .progress-bar.radio {
    cursor: default;
    opacity: 0;
    pointer-events: none;
  }

  .rail {
    position: absolute;
    left: 0;
    width: 100%;
    top: 6px;
    height: 2px;
    background: var(--c-border);
    transition: height 0.2s;
  }
  .fill {
    position: absolute;
    left: 0;
    top: 6px;
    height: 2px;
    background: var(--c-accent);
    pointer-events: none;
  }

  .progress-bar:hover .rail,
  .progress-bar:hover .fill {
    height: 4px;
    top: 5px;
  }

  .knob {
    position: absolute;
    right: -6px;
    top: -4px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--c-text-primary);
    transform: scale(0);
    transition: transform 0.2s;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
  }
  .progress-bar:hover .knob {
    transform: scale(1);
  }

  .tooltip {
    position: absolute;
    top: -28px;
    background: var(--c-surface-active);
    color: var(--c-text-primary);
    font-size: 11px;
    font-weight: bold;
    padding: 3px 6px;
    border-radius: 4px;
    transform: translateX(-50%);
    pointer-events: none;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  }

  /* Main Grid Layout */
  .grid {
    display: grid;
    grid-template-columns: 1fr max-content 1fr;
    height: 100%;
    padding: 0 32px;
    align-items: center;
    gap: 20px;
    position: relative;
    z-index: 5;
  }

  /* Info Section */
  .info {
    display: flex;
    align-items: center;
    gap: 16px;
    overflow: hidden;
  }
  .art {
    width: 56px;
    height: 56px;
    border-radius: 4px;
    background: var(--c-bg-placeholder);
    overflow: hidden;
    flex-shrink: 0;
    position: relative;
  }

  .icon-fallback {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--c-icon-faint);
  }
  .icon-fallback :global(svg) {
    width: 24px;
    height: 24px;
    opacity: 0.5;
  }

  .meta {
    display: flex;
    flex-direction: column;
    justify-content: center;
    overflow: hidden;
    min-width: 0;
  }

  .title-row {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 2px;
  }

  .title {
    font-size: 15px;
    font-weight: 500;
    color: var(--c-text-primary);
  }

  .artist-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .artist {
    font-size: 13px;
    color: var(--c-text-secondary);
  }

  /* Tiny context button */
  .tiny-dots {
    width: 24px;
    height: 24px;
    min-width: 24px;
    padding: 0;
    border-radius: 50%;
    color: var(--c-text-secondary);
    background: transparent;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  .tiny-dots:hover {
    color: var(--c-text-primary);
    opacity: 1;
  }

  /* Controls */
  .controls {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .play-btn {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: var(--c-text-primary);
    color: var(--c-text-inverse);
    box-shadow: 0 4px 12px var(--c-shadow-card);
    transition: transform 0.1s;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .play-btn:hover {
    transform: scale(1.05);
  }
  .play-btn:active {
    transform: scale(0.95);
  }
  .play-btn :global(svg) {
    width: 20px;
    height: 20px;
    fill: currentColor;
  }

  .mode-btn {
    position: relative;
    opacity: 0.7;
  }
  .mode-btn.active {
    opacity: 1;
    color: var(--c-accent);
  }
  .dot {
    position: absolute;
    bottom: 6px;
    width: 4px;
    height: 4px;
    background: var(--c-accent);
    border-radius: 50%;
    left: 50%;
    transform: translateX(-50%);
  }

  /* Volume */
  .volume {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 12px;
  }
  .vol-icon :global(svg) {
    fill: var(--c-text-secondary);
    width: 20px;
    height: 20px;
  }

  .custom-slider {
    width: 120px;
    height: 32px;
    display: flex;
    align-items: center;
    cursor: pointer;
    position: relative;
  }

  .slider-bg {
    width: 100%;
    height: 4px;
    background: var(--c-border);
    border-radius: 2px;
    position: relative;
  }

  .slider-fill {
    height: 100%;
    background: var(--c-text-primary);
    border-radius: 2px;
    position: absolute;
    left: 0;
    top: 0;
    pointer-events: none;
  }

  .slider-knob {
    width: 12px;
    height: 12px;
    background: #fff;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    pointer-events: none;
    opacity: 0;
    transition:
      opacity 0.2s,
      transform 0.1s;
  }

  .custom-slider:hover .slider-knob {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.1);
  }

  @media (max-width: 768px) {
    .desktop {
      display: none !important;
    }
    .grid {
      grid-template-columns: 1fr max-content;
      padding: 0 16px;
      gap: 12px;
    }
    .play-btn {
      width: 40px;
      height: 40px;
    }
    .art {
      width: 48px;
      height: 48px;
    }
  }
</style>

=== ./components/TrackRow.svelte ===
<script>
  import { createEventDispatcher } from "svelte";
  import { fade } from "svelte/transition";
  import ImageLoader from "./ImageLoader.svelte";
  import * as MPD from "../lib/mpd";
  import { ICONS } from "../lib/icons";
  import {
    currentSong,
    status,
    activeMenuTab,
    navigateTo,
    favorites,
    stations,
    getTrackThumbUrl,
    getTrackCoverUrl,
    openContextMenu,
    navigationStack,
  } from "../lib/store.js";
  import { longpress } from "../lib/actions";

  export let track;
  export let index;
  export let isEditable = false;

  const dispatch = createEventDispatcher();
  let isHovering = false;
  let imgError = false;

  $: if (track) imgError = false;

  $: isLiked = $favorites.has(track.file);
  $: isCurrent = track.file === $currentSong.file;
  $: isPlaying = $status.state === "play";

  $: isRadio =
    track.file &&
    (track.file.startsWith("http") || track.file.includes("RADIO"));

  $: showPause = isCurrent && isPlaying && isHovering;
  $: showPlay =
    (isCurrent && !isPlaying && isHovering) || (!isCurrent && isHovering);
  $: showEq = isCurrent && isPlaying && !isHovering;
  $: showStatic = isCurrent && !isPlaying && !isHovering;

  $: title = track.title || track.file?.split("/").pop();
  $: artist = track.artist || "Unknown";
  $: duration = formatDuration(track.time);

  $: quality = track.qualityBadge ? track.qualityBadge.split(" ")[0] : null; // оставляем только первое слово

  $: effectiveStationName = isCurrent ? $currentSong.stationName : null;

  $: imgUrl = imgError
    ? getTrackCoverUrl(track, $stations, effectiveStationName)
    : getTrackThumbUrl(track, "sm", $stations, effectiveStationName);

  function formatDuration(time) {
    if (isRadio) return "∞";
    if (!time) return "0:00";
    const sec = parseInt(time, 10);
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${s.toString().padStart(2, "0")}`;
  }

  function handleAction(e) {
    e.stopPropagation();
    if (isCurrent) MPD.togglePlay();
    else dispatch("play");
  }

  function getContextData() {
    const stack = $navigationStack;
    const currentView = stack[stack.length - 1];
    const tab = $activeMenuTab;

    if (currentView?.view === "details" && currentView.data?.name) {
      return { type: "playlist", playlistName: currentView.data.name, index };
    }

    if (
      currentView?.view === "queue" ||
      (currentView?.view === "root" && tab === "queue")
    ) {
      return { type: "queue", index };
    }

    return { type: "general" };
  }

  function handleMenuClick(e) {
    e.stopPropagation();
    openContextMenu(e, track, getContextData());
  }

  function handleLongPress(e) {
    if (isEditable) return;
    openContextMenu(e.detail.originalEvent, track, getContextData());
  }
</script>

<div
  class="row"
  class:active={isCurrent}
  class:editable={isEditable}
  on:click={() => !isCurrent && dispatch("play")}
  on:mouseenter={() => (isHovering = true)}
  on:mouseleave={() => (isHovering = false)}
  use:longpress
  on:longpress={handleLongPress}
  role="button"
  tabindex="0"
>
  <div class="left">
    {#if isEditable}
      <div
        class="drag-handle"
        on:mousedown={(e) => dispatch("startdrag", e)}
        on:touchstart|passive={(e) => dispatch("startdrag", e)}
        on:click|stopPropagation
        title="Drag to reorder"
      >
        <div class="icon-small">{@html ICONS.DRAG_HANDLE}</div>
      </div>
    {:else}
      <button class="num-box" on:click={handleAction}>
        {#if showEq}
          <div class="eq-anim">
            <span class="bar b1"></span>
            <span class="bar b2"></span>
            <span class="bar b3"></span>
          </div>
        {:else if showPause}
          <div class="icon-small">{@html ICONS.PAUSE}</div>
        {:else if showPlay}
          <div class="icon-small">{@html ICONS.PLAY}</div>
        {:else if showStatic}
          <div class="icon-small accent">{@html ICONS.PLAY}</div>
        {:else}
          <span class="num">{index + 1}</span>
        {/if}
      </button>
    {/if}

    <div class="thumb">
      <ImageLoader
        src={imgUrl}
        alt={title}
        radius="4px"
        on:error={() => (imgError = true)}
      >
        <div slot="fallback" class="icon-ph" in:fade>
          {@html isRadio ? ICONS.RADIO : ICONS.ALBUMS}
        </div>
      </ImageLoader>
    </div>
  </div>

  <div class="info">
    <div class="title-row">
      <div class="title text-ellipsis" {title}>{title}</div>
      {#if quality && !isRadio}
        <span class="quality-badge">{quality}</span>
      {/if}
    </div>
    <div
      class="artist text-ellipsis"
      class:link={!isRadio}
      on:click|stopPropagation={() => {
        if (!isRadio && track.artist) {
          activeMenuTab.set("artists");
          navigateTo("albums_by_artist", track.artist);
        }
      }}
    >
      {artist}
    </div>
  </div>

  <div class="right">
    <button
      class="btn-icon small context-menu-btn"
      title="Options"
      on:click={handleMenuClick}
    >
      {@html ICONS.DOTS}
    </button>

    <button
      class="btn-icon small"
      class:liked={isLiked}
      on:click|stopPropagation={() => MPD.toggleFavorite(track)}
    >
      {@html isLiked ? ICONS.HEART_FILLED : ICONS.HEART}
    </button>

    {#if isEditable}
      <button
        class="btn-icon small remove"
        on:click|stopPropagation={() => dispatch("remove", { index })}
      >
        {@html ICONS.REMOVE}
      </button>
    {:else}
      <div class="dur">{duration}</div>
    {/if}
  </div>
</div>

<style>
  .row {
    display: flex;
    align-items: center;
    width: 100%;
    height: 64px;
    padding: 0 16px;
    box-sizing: border-box;
    border-radius: var(--radius-md);
    border-bottom: 1px solid var(--c-border-dim);
    transition: background 0.2s;
    cursor: default;
    user-select: none;
    background: transparent;
  }
  .row:hover {
    background: var(--c-surface-hover);
  }
  .row.active {
    background: var(--c-surface-active);
  }

  .left {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-right: 16px;
    min-width: 80px;
  }

  .drag-handle {
    cursor: grab;
    color: var(--c-text-muted);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    margin-left: -8px;
  }
  .drag-handle:active {
    cursor: grabbing;
    color: var(--c-text-primary);
  }

  .num-box {
    width: 24px;
    height: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: transparent;
    border: none;
    padding: 0;
    cursor: pointer;
  }
  .num {
    font-size: 14px;
    color: var(--c-text-muted);
    font-variant-numeric: tabular-nums;
  }
  .active .num {
    color: var(--c-accent);
  }

  .icon-small {
    width: 16px;
    height: 16px;
    display: flex;
    fill: var(--c-text-primary);
  }
  .icon-small :global(svg) {
    width: 100%;
    height: 100%;
  }
  .icon-small.accent {
    color: var(--c-accent);
  }

  .eq-anim {
    display: flex;
    align-items: flex-end;
    height: 12px;
    width: 13px;
    justify-content: center;
  }
  .bar {
    width: 3px;
    background: var(--c-accent);
    margin: 0 1px;
    border-radius: 1px;
  }
  .b1 {
    animation: eq 0.6s infinite ease-in-out;
  }
  .b2 {
    animation: eq 0.6s infinite ease-in-out 0.2s;
  }
  .b3 {
    animation: eq 0.6s infinite ease-in-out 0.4s;
  }

  @keyframes eq {
    0%,
    100% {
      height: 3px;
    }
    50% {
      height: 12px;
    }
  }

  .thumb {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    background: var(--c-bg-placeholder);
    flex-shrink: 0;
    overflow: hidden;
  }
  .icon-ph {
    color: var(--c-icon-faint);
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .icon-ph :global(svg) {
    width: 20px;
    height: 20px;
  }

  .info {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  .title-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 2px;
    min-width: 0;
  }

  .title {
    font-size: 15px;
    font-weight: 500;
    color: var(--c-text-primary);
    line-height: 1.2;
  }
  .active .title {
    color: var(--c-accent);
  }

  .artist {
    font-size: 13px;
    color: var(--c-text-secondary);
    width: fit-content;
    max-width: 100%;
  }
  .artist.link:hover {
    text-decoration: underline;
    color: var(--c-text-primary);
    cursor: pointer;
  }

  .right {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .small {
    padding: 6px;
  }
  .small :global(svg) {
    width: 18px;
    height: 18px;
  }
  .remove {
    color: var(--c-text-muted);
  }
  .remove:hover {
    color: var(--c-accent);
  }

  .dur {
    font-size: 13px;
    color: var(--c-text-muted);
    font-variant-numeric: tabular-nums;
    width: 35px;
    text-align: right;
  }

  .context-menu-btn {
    opacity: 0.6;
    transition: opacity 0.2s;
  }
  .context-menu-btn:hover {
    opacity: 1;
    color: var(--c-text-primary);
  }
</style>

=== ./App.svelte ===
<script>
  import { onMount } from "svelte";
  import MainScreen from "./components/MainScreen.svelte";
  import ContextMenu from "./components/ContextMenu.svelte";
  import * as MPD from "./lib/mpd";
  import { ApiActions } from "./lib/api";
  import { db } from "./lib/db";
  import { Router } from "./lib/router";
  import { setNavigationCallback, showToast } from "./lib/store";
  import "./styles/shared.css";

  onMount(async () => {
    Router.init();
    setNavigationCallback((view, data) => {
      Router.updateUrl(view, data);
    });
    MPD.connect();
    ApiActions.loadRadioStations();
    try {
      const artists = await db.getArtists();
      if (artists.length > 0) {
        console.log(
          `[App] Database ready. Loaded ${artists.length} artists from cache.`,
        );
      } else {
        console.log("[App] Database empty. Starting initial sync...");
        ApiActions.syncLibrary();
      }
    } catch (e) {
      console.error("[App] DB Check failed:", e);
      showToast("Local DB error. Please update library manually.", "error");
    }
  });
</script>

<MainScreen />
<ContextMenu />

=== ./main.js ===
import { mount } from 'svelte'
import './app.css'
import App from './App.svelte'

const app = mount(App, {
  target: document.getElementById('app'),
})

export default app

=== ./config.js ===
const isDev = import.meta.env.DEV;

export const CONFIG = {
  // ... other settings
  DEFAULT_IP: isDev
    ? "192.168.1.100"
    : typeof window !== "undefined"
      ? window.location.hostname
      : "localhost",

  get MOODE_IP() {
    try {
      // localStorage is NOT available in Workers
      if (typeof localStorage !== "undefined") {
        return localStorage.getItem("moode_ip") || this.DEFAULT_IP;
      }
      return this.DEFAULT_IP;
    } catch (e) {
      return this.DEFAULT_IP;
    }
  },
};

=== lib/db.js ===
import { DATABASE } from "./constants";

export const db = {
  open() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DATABASE.NAME, DATABASE.VERSION);

      request.onupgradeneeded = (e) => {
        const database = e.target.result;
        const transaction = e.target.transaction;
        let store;

        if (database.objectStoreNames.contains(DATABASE.STORE_NAME)) {
          store = transaction.objectStore(DATABASE.STORE_NAME);
        } else {
          store = database.createObjectStore(DATABASE.STORE_NAME, {
            keyPath: "file",
          });
        }

        if (!store.indexNames.contains("artist")) {
          store.createIndex("artist", "artist", { unique: false });
        }
        if (!store.indexNames.contains("album")) {
          store.createIndex("album", "album", { unique: false });
        }
        if (!store.indexNames.contains("genre")) {
          store.createIndex("genre", "genre", { unique: false });
        }
        if (!store.indexNames.contains("album_artist")) {
          store.createIndex("album_artist", "album_artist", { unique: false });
        }
      };

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  async clear() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readwrite");
      tx.objectStore(DATABASE.STORE_NAME).clear();
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },

  async bulkAdd(tracks) {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readwrite");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      tracks.forEach((track) => store.put(track));
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },

  async getFilesMap(files) {
    if (!files || files.length === 0) return new Map();
    const database = await this.open();
    return new Promise((resolve) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const resultMap = new Map();
      let loaded = 0;
      files.forEach((rawFile) => {
        const searchKey = rawFile.normalize("NFC").trim();
        const req = store.get(searchKey);
        req.onsuccess = (e) => {
          if (e.target.result) resultMap.set(rawFile, e.target.result);
          loaded++;
          if (loaded === files.length) resolve(resultMap);
        };
        req.onerror = () => {
          loaded++;
          if (loaded === files.length) resolve(resultMap);
        };
      });
    });
  },

  async getArtists() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const uniqueMap = new Map();
      const request = store.openCursor();
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const t = cursor.value;
          const effectiveName = t.album_artist || t.artist;
          if (effectiveName && !uniqueMap.has(effectiveName)) {
            uniqueMap.set(effectiveName, {
              name: effectiveName,
              file: t.file,
              thumbHash: t.thumbHash,
            });
          }
          cursor.continue();
        } else {
          const sorted = Array.from(uniqueMap.values()).sort((a, b) =>
            a.name.localeCompare(b.name, undefined, { sensitivity: "base" }),
          );
          resolve(sorted);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getAlbums() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("album");
      const albums = [];
      const request = index.openCursor(null, "nextunique");
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const t = cursor.value;
          albums.push({
            name: t.album,
            artist: t.album_artist || t.artist,
            file: t.file,
            thumbHash: t.thumbHash,
            qualityBadge: t.qualityBadge,
            year: t.year || 0,
          });
          cursor.continue();
        } else {
          resolve(albums);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getArtistAlbums(artistName) {
    if (!artistName) return [];
    const database = await this.open();
    const safeArtist = artistName.normalize("NFC").trim();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const p1 = new Promise((res) => {
        if (store.indexNames.contains("album_artist")) {
          store
            .index("album_artist")
            .getAll(IDBKeyRange.only(safeArtist)).onsuccess = (e) =>
            res(e.target.result);
        } else res([]);
      });
      const p2 = new Promise((res) => {
        store.index("artist").getAll(IDBKeyRange.only(safeArtist)).onsuccess = (
          e,
        ) => res(e.target.result);
      });
      Promise.all([p1, p2])
        .then(([r1, r2]) => {
          const allTracks = [...r1, ...r2];
          const uniqueAlbums = [];
          const seenAlbums = new Set();
          allTracks.forEach((t) => {
            if (!seenAlbums.has(t.album)) {
              seenAlbums.add(t.album);
              uniqueAlbums.push({
                name: t.album,
                artist: t.album_artist || t.artist,
                file: t.file,
                thumbHash: t.thumbHash,
                qualityBadge: t.qualityBadge,
                year: t.year || 0,
              });
            }
          });
          resolve(uniqueAlbums);
        })
        .catch((err) => reject(err));
    });
  },

  async getAlbumTracks(albumName, artistFilter = null) {
    const database = await this.open();
    // Нормализуем входные данные
    const safeAlbum = albumName.normalize("NFC").trim();
    const safeArtist = artistFilter
      ? artistFilter.normalize("NFC").trim()
      : null;

    console.log(
      `[DB] getAlbumTracks called. Album: "${safeAlbum}", FilterArtist: "${safeArtist}"`,
    );

    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("album");

      // 1. Получаем ВСЕ треки с таким названием альбома (например, "Film Music")
      const range = IDBKeyRange.only(safeAlbum);
      const request = index.getAll(range);

      request.onsuccess = () => {
        let tracks = request.result;
        console.log(
          `[DB] Found ${tracks.length} raw tracks for album "${safeAlbum}"`,
        );

        // 2. Если указан фильтр по артисту, оставляем только его треки
        if (safeArtist) {
          const beforeCount = tracks.length;
          tracks = tracks.filter((t) => {
            const tArtist = (t.artist || "").normalize("NFC").trim();
            const tAlbumArtist = (t.album_artist || "").normalize("NFC").trim();

            const match = tArtist === safeArtist || tAlbumArtist === safeArtist;

            if (!match) {
            }
            return match;
          });
          console.log(
            `[DB] After artist filter: ${tracks.length} tracks (Removed ${beforeCount - tracks.length})`,
          );
        } else {
          console.log("[DB] No artist filter provided. Returning all tracks.");
        }

        // 3. Сортировка
        tracks.sort((a, b) => {
          const discA = parseInt(a.disc || 1);
          const discB = parseInt(b.disc || 1);
          if (discA !== discB) return discA - discB;
          const trA = parseInt(a.track || 0);
          const trB = parseInt(b.track || 0);
          return trA - trB;
        });
        resolve(tracks);
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getGenres() {
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("genre");
      const genres = [];
      const request = index.openKeyCursor(null, "nextunique");
      request.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          genres.push(cursor.key);
          cursor.continue();
        } else {
          resolve(genres);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },

  async getGenreTracks(genre) {
    const database = await this.open();
    const safeGenre = genre.normalize("NFC").trim();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const index = tx.objectStore(DATABASE.STORE_NAME).index("genre");
      const request = index.getAll(IDBKeyRange.only(safeGenre));
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },

  async search(query) {
    if (!query) return [];
    const q = query.toLowerCase().normalize("NFC").trim();
    const database = await this.open();
    return new Promise((resolve, reject) => {
      const tx = database.transaction(DATABASE.STORE_NAME, "readonly");
      const store = tx.objectStore(DATABASE.STORE_NAME);
      const results = [];
      const MAX_RESULTS = 100;
      const request = store.openCursor();
      request.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          const t = cursor.value;
          const match =
            (t.title && t.title.toLowerCase().includes(q)) ||
            (t.artist && t.artist.toLowerCase().includes(q)) ||
            (t.album && t.album.toLowerCase().includes(q)) ||
            (t.album_artist && t.album_artist.toLowerCase().includes(q));
          if (match) {
            results.push(t);
          }
          if (results.length >= MAX_RESULTS) {
            resolve(results);
            return;
          }
          cursor.continue();
        } else {
          resolve(results);
        }
      };
      request.onerror = () => reject(request.error);
    });
  },
};

=== lib/index.js ===
// 1. Экспортируем всё для MPD (управление)
// Убедитесь, что в lib/mpd/index.js больше НЕТ syncLibrary
export * from "./mpd";

// 2. Экспортируем всё для API (синхронизация)
export { ApiActions } from "./api";

// Helper для удобного импорта одиночной функции
import { ApiActions } from "./api";
export const syncLibrary = ApiActions.syncLibrary;

=== lib/router.js ===
import { get } from "svelte/store";
import {
  activeMenuTab,
  navigationStack,
  searchQuery,
  consumeRouteData,
} from "./store";

export const Router = {
  init() {
    this.handleHashChange();
    window.addEventListener("hashchange", () => this.handleHashChange());
  },

  handleHashChange() {
    let raw = window.location.hash.slice(1);
    while (raw.startsWith("/")) {
      raw = raw.slice(1);
    }

    if (!raw) {
      if (get(navigationStack).length > 1 || get(activeMenuTab) === "search") {
        this.setRootTab("artists");
        window.location.hash = "/artists";
      }
      return;
    }

    const parts = raw.split("/").map(decodeURIComponent);
    const route = parts[0];

    let data = consumeRouteData();

    if (!data) {
      if (parts.length > 1) {
        if (route === "album" && parts.length >= 3) {
          // ФОРМАТ: #/album/Artist Name/Album Name
          data = { artist: parts[1], name: parts[2] };
        } else if (route === "artist" && parts.length >= 2) {
          data = { name: parts[1] };
        } else {
          // Старый формат (fallback)
          data = { name: parts[1], displayName: parts[1] };
        }
      }
    }

    console.log(`[Router] Navigating: ${route}`, data);

    switch (route) {
      case "queue":
        this.setRootTab("queue");
        break;
      case "radio":
        this.setRootTab("radio");
        break;
      case "playlists":
        this.setRootTab("playlists");
        break;
      case "favorites":
        activeMenuTab.set("favorites");
        navigationStack.set([
          { view: "root" },
          { view: "details", data: { name: "Favorites" } },
        ]);
        break;

      case "artists":
        this.setRootTab("artists");
        break;
      case "albums":
        this.setRootTab("albums");
        break;
      case "search":
        activeMenuTab.set("search");
        if (parts[1]) searchQuery.set(parts[1]);
        navigationStack.set([{ view: "root" }]);
        break;

      case "album":
        activeMenuTab.set("albums");
        navigationStack.set([
          { view: "root" },
          { view: "tracks_by_album", data: data },
        ]);
        break;

      case "artist":
        activeMenuTab.set("artists");
        navigationStack.set([
          { view: "root" },
          { view: "albums_by_artist", data: data },
        ]);
        break;

      case "playlist":
        activeMenuTab.set("playlists");
        navigationStack.set([
          { view: "root" },
          { view: "details", data: data },
        ]);
        break;

      default:
        this.setRootTab("artists");
        break;
    }
  },

  setRootTab(tab) {
    activeMenuTab.set(tab);
    navigationStack.set([{ view: "root" }]);
  },

  updateUrl(view, data) {
    let newPath = "";

    if (view === "root") {
      const tab = get(activeMenuTab);
      if (tab === "search") {
        const q = get(searchQuery);
        newPath = q ? `search/${encodeURIComponent(q)}` : "search";
      } else {
        newPath = tab;
      }
    } else if (view === "details") {
      const name = data.name || data;
      newPath =
        name === "Favorites"
          ? "favorites"
          : `playlist/${encodeURIComponent(name)}`;
    } else if (view === "albums_by_artist") {
      const name = data.name || data;
      newPath = `artist/${encodeURIComponent(name)}`;
    } else if (view === "tracks_by_album") {
      const name = data.name || data;
      const artist = data.artist;

      if (artist) {
        newPath = `album/${encodeURIComponent(artist)}/${encodeURIComponent(name)}`;
      } else {
        newPath = `album/${encodeURIComponent(name)}`;
      }
    } else if (view === "queue") {
      newPath = "queue";
    }

    if (newPath) {
      const nextHash = `#/${newPath}`;
      if (
        decodeURIComponent(window.location.hash) !==
        decodeURIComponent(nextHash)
      ) {
        window.location.hash = `/${newPath}`;
      }
    }
  },
};

=== lib/playlistDrag.js ===
import { writable, get } from "svelte/store";
import { tick } from "svelte";

const SCROLL_ZONE_PX = 100;
const SCROLL_SPEED_BASE = 5;
const SCROLL_SPEED_MAX = 25;
const DRAG_THRESHOLD = 3;

export function createPlaylistDrag({ tracksStore, onMoveTrack }) {
  const isDragging = writable(false);
  const isDropping = writable(false);
  const isReordering = writable(false);

  const draggingIndex = writable(null);
  const hoverIndex = writable(null);
  const justDroppedIndex = writable(null);

  const ghostCoords = writable({
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    grabOffsetX: 0,
    grabOffsetY: 0,
  });
  const draggedItemData = writable(null);

  let isDown = false;
  let startX = 0;
  let startY = 0;
  let currentX = 0;
  let currentY = 0;

  const refs = {
    scrollContainer: null,
    listBodyContainer: null,
  };

  let scrollInterval = null;

  function onDragInit(event, index, track) {
    const e = event.detail;
    if (e.button === 2) return;
    if (window.getSelection) window.getSelection().removeAllRanges();

    if (!refs.scrollContainer) return;

    const rows = refs.scrollContainer.querySelectorAll(".row-wrapper");
    const targetRow = rows[index];
    if (!targetRow) return;

    const rect = targetRow.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    const grabOffsetX = clientX - rect.left;
    const grabOffsetY = clientY - rect.top;

    isDown = true;
    isDragging.set(false);
    isDropping.set(false);

    startX = clientX;
    startY = clientY;
    currentX = clientX;
    currentY = clientY;

    draggingIndex.set(index);
    hoverIndex.set(index);
    draggedItemData.set(track);
    justDroppedIndex.set(null);

    ghostCoords.set({
      x: clientX,
      y: clientY,
      width: rect.width,
      height: rect.height,
      grabOffsetX,
      grabOffsetY,
    });
  }

  function onPointerMove(e) {
    if (!isDown || get(isDropping)) return;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    if (!get(isDragging)) {
      const dx = Math.abs(clientX - startX);
      const dy = Math.abs(clientY - startY);
      if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) return;
      isDragging.set(true);
    }

    if (e.cancelable) e.preventDefault();

    currentX = clientX;
    currentY = clientY;

    ghostCoords.update((c) => ({ ...c, x: currentX, y: currentY }));

    handleAutoScroll(currentY);
    calculateHoverIndex();
  }

  function calculateHoverIndex() {
    if (!refs.listBodyContainer) return;

    const listRect = refs.listBodyContainer.getBoundingClientRect();
    const gCoords = get(ghostCoords);

    const mouseRelativeY = currentY - listRect.top;
    const ghostCenterInList =
      mouseRelativeY - gCoords.grabOffsetY + gCoords.height / 2;

    const tracksCount = get(tracksStore).length;

    if (ghostCenterInList < 0) {
      hoverIndex.set(0);
      return;
    }
    if (ghostCenterInList > listRect.height) {
      hoverIndex.set(tracksCount);
      return;
    }

    const rows = Array.from(
      refs.listBodyContainer.querySelectorAll(".row-wrapper"),
    );
    let bestIndex = -1;
    let minDistance = Infinity;

    // Мы должны учитывать расстояние до оригинального слота, чтобы можно было вернуть трек назад.
    rows.forEach((row, idx) => {
      const rowCenterY = row.offsetTop + row.offsetHeight / 2;
      const dist = Math.abs(ghostCenterInList - rowCenterY);

      if (dist < minDistance) {
        minDistance = dist;
        bestIndex = idx;
      }
    });

    if (bestIndex !== -1) {
      hoverIndex.set(bestIndex);
    }
  }

  function onPointerUp(e) {
    if (!isDown) return;
    isDown = false;

    if (!get(isDragging)) {
      cancelDrag();
      return;
    }
    commitDrop();
  }

  async function commitDrop() {
    stopAutoScroll();

    // 1. Фаза полета
    isDragging.set(false);
    isDropping.set(true);

    const finalHoverIndex = get(hoverIndex);
    const gCoords = get(ghostCoords);

    // Расчет координат для анимации полета (без изменений)
    if (refs.listBodyContainer && finalHoverIndex !== null) {
      const rows = refs.listBodyContainer.querySelectorAll(".row-wrapper");
      const targetRow = rows[finalHoverIndex];
      if (targetRow) {
        const listRect = refs.listBodyContainer.getBoundingClientRect();
        const targetTopScreen = listRect.top + targetRow.offsetTop;
        const targetLeftScreen = listRect.left + targetRow.offsetLeft;
        ghostCoords.update((c) => ({
          ...c,
          y: targetTopScreen + c.grabOffsetY,
          x: targetLeftScreen + c.grabOffsetX,
        }));
      }
    }

    // Ждем анимацию полета
    await new Promise((resolve) => setTimeout(resolve, 200));

    // Блокируем анимации
    isReordering.set(true);

    // Ждем, пока Svelte добавит класс в DOM
    await tick();

    // Без этого на мобилке класс применяется слишком поздно.
    if (refs.listBodyContainer) {
      const _forceReflow = refs.listBodyContainer.offsetHeight;
    }

    // Теперь, когда анимации гарантированно выключены, меняем всё разом.
    const currentDragIdx = get(draggingIndex);
    const maxIndex = get(tracksStore).length;
    let validIndex = Math.max(0, Math.min(finalHoverIndex, maxIndex));
    let insertAt = validIndex;

    if (currentDragIdx !== null && currentDragIdx !== validIndex) {
      const tracks = [...get(tracksStore)];
      const [item] = tracks.splice(currentDragIdx, 1);

      insertAt = Math.max(0, Math.min(insertAt, tracks.length));
      tracks.splice(insertAt, 0, item);

      // Обновляем массив
      tracksStore.set(tracks);

      if (onMoveTrack) {
        onMoveTrack(currentDragIdx, insertAt);
      }
    }

    // Мгновенно сбрасываем индексы.
    draggingIndex.set(null);
    hoverIndex.set(null);
    draggedItemData.set(null);
    isDropping.set(false);

    // Включаем анимацию приземления для нового элемента
    const droppedAt = currentDragIdx !== validIndex ? insertAt : currentDragIdx;
    justDroppedIndex.set(droppedAt);

    // Ждем отрисовки нового состояния DOM
    await tick();

    // Возвращаем анимации обратно
    requestAnimationFrame(() => {
      isReordering.set(false);
      setTimeout(() => {
        justDroppedIndex.set(null);
      }, 300);
    });
  }
  function cancelDrag() {
    isDown = false;
    resetDragState();
  }

  function resetDragState() {
    isDragging.set(false);
    isDropping.set(false);
    draggingIndex.set(null);
    hoverIndex.set(null);
    draggedItemData.set(null);
    stopAutoScroll();
  }

  function handleAutoScroll(y) {
    if (!refs.scrollContainer) return;
    const { top, bottom } = refs.scrollContainer.getBoundingClientRect();
    const distTop = y - top;
    const distBottom = bottom - y;

    stopAutoScroll();
    let speed = 0;

    if (distTop < SCROLL_ZONE_PX && distTop > 0) {
      const intensity = 1 - distTop / SCROLL_ZONE_PX;
      speed = -(SCROLL_SPEED_BASE + SCROLL_SPEED_MAX * (intensity * intensity));
    } else if (distBottom < SCROLL_ZONE_PX && distBottom > 0) {
      const intensity = 1 - distBottom / SCROLL_ZONE_PX;
      speed = SCROLL_SPEED_BASE + SCROLL_SPEED_MAX * (intensity * intensity);
    }

    if (speed !== 0) startAutoScroll(speed);
  }

  function startAutoScroll(speed) {
    if (scrollInterval) return;
    scrollInterval = requestAnimationFrame(function tickLoop() {
      if (!refs.scrollContainer) return;
      refs.scrollContainer.scrollTop += speed;

      if (get(isDragging)) {
        const fakeEvent = {
          touches: [{ clientX: currentX, clientY: currentY }],
          clientX: currentX,
          clientY: currentY,
          preventDefault: () => {},
        };
        ghostCoords.update((c) => ({ ...c, x: currentX, y: currentY }));
        calculateHoverIndex();

        scrollInterval = requestAnimationFrame(tickLoop);
      }
    });
  }

  function stopAutoScroll() {
    if (scrollInterval) {
      cancelAnimationFrame(scrollInterval);
      scrollInterval = null;
    }
  }

  function getRowStyle(
    index,
    isDraggingVal,
    isDroppingVal,
    dragIdxVal,
    hoverIdxVal,
    isReorderingVal,
  ) {
    // Пусть DOM элементы встанут на свои новые места чисто.
    if (isReorderingVal) return "";

    if (
      (!isDraggingVal && !isDroppingVal) ||
      dragIdxVal === null ||
      hoverIdxVal === null
    )
      return "";

    // Скрытие элемента под пальцем
    if (index === dragIdxVal) {
      return "opacity: 0; pointer-events: none;";
    }

    if (dragIdxVal === hoverIdxVal) return "";

    // Сдвиги
    if (dragIdxVal < hoverIdxVal) {
      if (index > dragIdxVal && index <= hoverIdxVal) {
        return "transform: translateY(-100%);";
      }
    }

    if (dragIdxVal > hoverIdxVal) {
      if (index >= hoverIdxVal && index < dragIdxVal) {
        return "transform: translateY(100%);";
      }
    }
    return "";
  }

  return {
    isDragging,
    isDropping,
    isReordering,
    draggingIndex,
    hoverIndex,
    justDroppedIndex,
    draggedItemData,
    ghostCoords,
    refs,
    onDragInit,
    onPointerMove,
    onPointerUp,
    getRowStyle,
    cancelDrag,
  };
}

=== lib/api.js ===
import { get } from "svelte/store";
import { CONFIG } from "../config";
import { API_ENDPOINTS } from "./constants";
import { isSyncingLibrary, showToast, isLoadingRadio, stations } from "./store";
import SyncWorker from "./workers/sync.worker.js?worker";

/**
 * Actions for interacting with the wave-api.php backend.
 */
export const ApiActions = {
  /**
   * Starts library synchronization via Web Worker to prevent UI blocking during large JSON parsing.
   */
  async syncLibrary() {
    if (get(isSyncingLibrary)) return;

    isSyncingLibrary.set(true);
    const worker = new SyncWorker();

    const apiUrl = window.location.origin + "/wave-api.php";

    worker.postMessage({
      type: "START_SYNC",
      payload: {
        url: apiUrl,
      },
    });

    worker.onmessage = (e) => {
      const { type, status, count, message } = e.data;

      if (type === "PROGRESS") {
        const labels = {
          connecting: "Requesting library...",
          downloading: "Downloading data...",
          parsing: "Processing metadata...",
          saving: `Saving ${count} tracks...`,
        };
        if (labels[status]) showToast(labels[status], "info");
      }

      if (type === "DONE") {
        showToast(`Library updated: ${count} tracks`, "success");
        isSyncingLibrary.set(false);
        worker.terminate();
      }

      if (type === "ERROR") {
        console.error("[API] Sync Error:", message);
        showToast(`Sync Failed: ${message}`, "error");
        isSyncingLibrary.set(false);
        worker.terminate();
      }
    };

    worker.onerror = (err) => {
      console.error("[API] Worker crash:", err);
      showToast("Sync worker crashed", "error");
      isSyncingLibrary.set(false);
      worker.terminate();
    };
  },

  /**
   * Loads radio station list and normalizes it for the player.
   */
  async loadRadioStations() {
    if (get(isLoadingRadio)) return;

    isLoadingRadio.set(true);
    try {
      const isDev = import.meta.env.DEV;
      const res = await fetch(API_ENDPOINTS.STATIONS(isDev));

      if (!res.ok) throw new Error("Network error");

      const rawData = await res.json();
      if (rawData.error) throw new Error(rawData.error);
      if (!Array.isArray(rawData)) throw new Error("Invalid response format");

      const normalized = rawData.map((item) => ({
        id: item.id,
        name: item.name,
        file: item.station, // Player expects 'file' for playback
        station: item.station,
        image: item.logo, // Raw value: 'local', URL, or filename
        genre: item.genre || "Radio",
      }));

      // Sort alphabetically by name
      normalized.sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { sensitivity: "base" }),
      );

      stations.set(normalized);
    } catch (e) {
      console.error("[API] Failed to load stations", e);
      showToast("Failed to load radio", "error");
    } finally {
      isLoadingRadio.set(false);
    }
  },
};

=== lib/icons.js ===
/**
 * Icon Collection for Wave-UI Moode.
 * Strictly using existing files from ./lib/svg
 */

// Импортируем содержимое файлов как строки (Vite raw import)
import arrowsShuffle2 from "./svg/arrows-shuffle-2.svg?raw";
import brandDeezer from "./svg/brand-deezer.svg?raw";
import chevronCompactDown from "./svg/chevron-compact-down.svg?raw";
import chevronCompactLeft from "./svg/chevron-compact-left.svg?raw";
import chevronLeft from "./svg/chevron-left.svg?raw";
import disc from "./svg/disc.svg?raw";
import gripHorizontal from "./svg/grip-horizontal.svg?raw";
import heartEmpty from "./svg/heart-empty.svg?raw";
import heartFilled from "./svg/heart-filled.svg?raw";
import menu2 from "./svg/menu-2.svg?raw";
import music from "./svg/music.svg?raw";
import playerPause from "./svg/player-pause.svg?raw";
import playerPlayEmpty from "./svg/player-play-empty.svg?raw";
import playerPlayFilled from "./svg/player-play-filled.svg?raw";
import playerSkipBack from "./svg/player-skip-back.svg?raw";
import playerSkipForward from "./svg/player-skip-forward.svg?raw";
import playlist from "./svg/playlist.svg?raw";
import radio from "./svg/radio.svg?raw";
import refresh from "./svg/refresh.svg?raw";
import repeat from "./svg/repeat.svg?raw";
import search from "./svg/search.svg?raw";
import settings from "./svg/settings.svg?raw";
import trash from "./svg/trash.svg?raw";
import volumeFull from "./svg/volume-full.svg?raw";
import volumeMedium from "./svg/volume-medium.svg?raw";
import volumeMute from "./svg/volume-mute.svg?raw";
import volumeOff from "./svg/volume-off.svg?raw";
import x from "./svg/x.svg?raw";
import deviceFloppy from "./svg/device-floppy.svg?raw";
import filePencil from "./svg/file-pencil.svg?raw";
import plus from "./svg/plus.svg?raw";
import circleCheck from "./svg/circle-check.svg?raw";
import dots from "./svg/dots.svg?raw";
import sortDescending from "./svg/sort-descending.svg?raw";
import sortAscending from "./svg/sort-ascending.svg?raw";

export const ICONS = {
  ARTISTS: music,
  ALBUMS: disc,
  GENRES: music,
  PLAYLISTS: playlist,
  RADIO: radio,
  SEARCH: search,

  PLAY: playerPlayFilled,
  PLAY_OUTLINE: playerPlayEmpty,
  PAUSE: playerPause,
  PREVIOUS: playerSkipBack,
  NEXT: playerSkipForward,
  SHUFFLE: arrowsShuffle2,
  REPEAT: repeat,

  VOLUME_FULL: volumeFull,
  VOLUME_MEDIUM: volumeMedium,
  VOLUME_MUTE: volumeMute,
  VOLUME_OFF: volumeOff,

  HEART: heartEmpty,
  HEART_FILLED: heartFilled,

  SYNC: refresh,
  SETTINGS: settings,
  CLOSE: x,
  MENU: menu2,
  BACK: chevronLeft,
  BACK_COMPACT: chevronCompactLeft,
  CHEVRON_DOWN: chevronCompactDown,
  DRAG_HANDLE: gripHorizontal,
  REMOVE: trash,
  DEEZER: brandDeezer,
  SAVE: deviceFloppy,
  EDIT: filePencil,
  ADD: plus,
  ACCEPT: circleCheck,

  DOTS: dots,
  ADD_TO_PLAYLIST: plus,
  ALBUM_LINK: disc,
  ARTIST_LINK: music,

  SORT_DESC: sortDescending,
  SORT_ASC: sortAscending,
};

=== lib/workers/sync.worker.js ===
import { db } from "../db";
import md5 from "md5";

let apiUrl;

function decodeEntities(str) {
  if (!str) return "";
  if (typeof str !== "string") return String(str);
  return str
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#039;/g, "'")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">");
}

self.onmessage = async (e) => {
  const { type, payload } = e.data;

  if (type === "START_SYNC") {
    apiUrl = payload.url;
    await startSync();
  }
};

async function startSync() {
  try {
    self.postMessage({ type: "PROGRESS", status: "connecting" });

    const response = await fetch(apiUrl);

    if (!response.ok) {
      const errText = await response.text();
      throw new Error(
        `HTTP Error ${response.status}: ${errText.substring(0, 100)}`,
      );
    }

    self.postMessage({ type: "PROGRESS", status: "downloading" });

    const textData = await response.text();
    const trimmed = textData.trim();

    if (trimmed.length === 0) {
      throw new Error("Server returned empty response");
    }

    if (trimmed.charAt(0) !== "[" && trimmed.charAt(0) !== "{") {
      console.error(
        "CRITICAL: Server returned non-JSON data:",
        textData.substring(0, 500),
      );
      throw new Error(
        `Invalid JSON. Server says: ${textData.substring(0, 100)}...`,
      );
    }

    let rawData;
    try {
      rawData = JSON.parse(textData);
    } catch (e) {
      throw new Error("JSON Parse Error: " + e.message);
    }

    if (!Array.isArray(rawData)) {
      if (rawData.error) {
        throw new Error("API Error: " + rawData.error);
      }
      if (Object.keys(rawData).length === 0) {
        rawData = [];
      } else {
        throw new Error("Invalid response format: expected JSON array");
      }
    }

    self.postMessage({
      type: "PROGRESS",
      status: "parsing",
      count: rawData.length,
    });

    const tracks = rawData.map((item) => {
      const file = (item.file || "").normalize("NFC").trim();
      const title = decodeEntities(item.title || file.split("/").pop())
        .normalize("NFC")
        .trim();

      const rawArtist = Array.isArray(item.artist)
        ? item.artist.join(", ")
        : item.artist || "Unknown Artist";
      const artist = decodeEntities(rawArtist).normalize("NFC").trim();

      const album = decodeEntities(item.album || "Unknown Album")
        .normalize("NFC")
        .trim();

      const rawGenre = Array.isArray(item.genre)
        ? item.genre.join(", ")
        : item.genre || "Unknown";
      const genre = decodeEntities(rawGenre).normalize("NFC").trim();

      // Обработка Album Artist (несколько вариантов ключей)
      const rawAlbumArtist =
        item.album_artist || item.albumartist || item.AlbumArtist;
      const album_artist = rawAlbumArtist
        ? decodeEntities(rawAlbumArtist).normalize("NFC").trim()
        : null;

      // Генерация хеша для обложек на основе пути к папке
      let thumbHash = null;
      if (file) {
        try {
          const lastSlashIndex = file.lastIndexOf("/");
          const dirPath =
            lastSlashIndex === -1 ? "." : file.substring(0, lastSlashIndex);

          thumbHash = md5(dirPath);
        } catch (err) {
          console.warn("Failed to generate thumb hash for", file);
        }
      }

      let qualityBadge = null;
      if (item.encoded_at) {
        qualityBadge = item.encoded_at.replace(/,/g, " ").trim();
      }

      return {
        file,
        title,
        artist,
        album,
        genre,
        album_artist,

        time: parseFloat(item.time || 0),
        track: parseInt(item.tracknum || 0),
        disc: parseInt(item.disc || 1),
        year: parseInt(item.year || 0),

        encoded_at: item.encoded_at,
        last_modified: item.last_modified,

        thumbHash,
        qualityBadge,
      };
    });

    self.postMessage({
      type: "PROGRESS",
      status: "saving",
      count: tracks.length,
    });

    await db.clear();
    await db.bulkAdd(tracks);

    self.postMessage({ type: "DONE", count: tracks.length });
  } catch (e) {
    console.error(e);
    self.postMessage({ type: "ERROR", message: e.message });
  }
}

=== lib/mpd/library.js ===
import { get } from "svelte/store";
import { mpdClient } from "./client";
import { MpdParser } from "./parser";
import { CONFIG } from "../../config";
import {
  isSyncingLibrary,
  isLoadingPlaylists,
  playlists,
  isLoadingTracks,
  activePlaylistTracks,
  showToast,
  favorites,
} from "../store";
import { db } from "../db";
import SyncWorker from "../workers/sync.worker.js?worker";
import { generateUid } from "../utils";

const FAV_PLAYLIST = "Favorites";

let _favActionQueue = Promise.resolve();

const normFile = (path) => {
  if (!path) return "";
  try {
    let p = decodeURIComponent(path).normalize("NFC");
    if (p.startsWith("/")) p = p.slice(1);
    return p.trim().toLowerCase();
  } catch (e) {
    return String(path).toLowerCase();
  }
};

const cleanUrl = (url) => {
  if (!url) return "";
  return url
    .toLowerCase()
    .replace(/^https?:\/\//, "")
    .replace(/^www\./, "")
    .split("?")[0]
    .replace(/\/$/, "");
};

function getGradient(name) {
  if (name === "Favorites") {
    return `linear-gradient(135deg, hsl(348, 95%, 58%), hsl(348, 90%, 40%))`;
  }
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash % 360);
  return `linear-gradient(135deg, hsl(${hue}, 60%, 40%), hsl(${(hue + 40) % 360}, 60%, 30%))`;
}

export const LibraryActions = {
  async syncLibrary() {
    if (get(isSyncingLibrary)) return;
    isSyncingLibrary.set(true);

    const worker = new SyncWorker();
    worker.postMessage({
      type: "START_SYNC",
      payload: { url: `http://${CONFIG.MOODE_IP}/wave-api.php` },
    });

    worker.onmessage = (e) => {
      const { type, count } = e.data;
      if (type === "DONE") {
        showToast(`Library updated: ${count} tracks`, "success");
        isSyncingLibrary.set(false);
        worker.terminate();
      }
      if (type === "ERROR") {
        showToast("Sync Failed", "error");
        isSyncingLibrary.set(false);
        worker.terminate();
      }
    };
    worker.onerror = () => {
      isSyncingLibrary.set(false);
      worker.terminate();
    };
  },

  async loadPlaylists() {
    isLoadingPlaylists.set(true);
    try {
      const text = await mpdClient.send("listplaylists");
      const rawPlaylists = MpdParser.parsePlaylists(text);

      const enhanced = rawPlaylists.map((pl) => ({
        ...pl,
        color: getGradient(pl.name),
      }));

      playlists.set(enhanced);
    } catch (e) {
      console.error(e);
    } finally {
      isLoadingPlaylists.set(false);
    }
  },

  async openPlaylistDetails(playlistName) {
    if (!playlistName) return;
    isLoadingTracks.set(true);
    const safeName = playlistName.replace(/"/g, '\\"');
    try {
      const text = await mpdClient.send(`listplaylistinfo "${safeName}"`);
      const rawTracks = MpdParser.parseTracks(text);

      // Собираем пути файлов, чтобы найти их в DB
      const filesToLookup = rawTracks
        .map((t) => t.file)
        .filter((f) => f && !f.startsWith("http"));

      let cachedMap = new Map();
      if (filesToLookup.length > 0) {
        try {
          cachedMap = await db.getFilesMap(filesToLookup);
        } catch (dbErr) {
          console.warn("Failed to hydrate playlist from DB", dbErr);
        }
      }

      const enrichedTracks = rawTracks.map((track) => {
        const cached = cachedMap.get(track.file);
        if (cached) {
          return {
            ...track,
            // Дополняем данными из базы
            thumbHash: cached.thumbHash,
            qualityBadge: cached.qualityBadge,
            // Если в MPD нет title/artist, берем из базы (fallback)
            title: track.title || cached.title,
            artist: track.artist || cached.artist,
            album: track.album || cached.album,
            _uid: generateUid(),
          };
        }
        return {
          ...track,
          _uid: generateUid(),
        };
      });
      // --- HYDRATION END ---

      activePlaylistTracks.set(enrichedTracks);
    } catch (e) {
      console.error(e);
      showToast("Could not load playlist", "error");
    } finally {
      isLoadingTracks.set(false);
    }
  },

  async movePlaylistTrack(playlistName, fromPos, toPos) {
    const safeName = playlistName.replace(/"/g, '\\"');
    try {
      await mpdClient.send(`playlistmove "${safeName}" ${fromPos} ${toPos}`);
    } catch (e) {
      showToast("Move failed", "error");
    }
  },

  async removeFromPlaylist(playlistName, pos) {
    const safeName = playlistName.replace(/"/g, '\\"');
    try {
      await mpdClient.send(`playlistdelete "${safeName}" ${pos}`);
      showToast("Track removed", "success");
    } catch (e) {
      showToast("Delete failed", "error");
    }
  },

  async loadFavorites() {
    try {
      const text = await mpdClient.send(`listplaylistinfo "${FAV_PLAYLIST}"`);
      const tracks = MpdParser.parseTracks(text);

      const favSet = new Set();
      tracks.forEach((t) => {
        if (t.file) {
          favSet.add(t.file);
        }
      });

      favorites.set(favSet);
    } catch (e) {
      favorites.set(new Set());
    }
  },

  async toggleFavorite(track) {
    if (!track || !track.file) return;

    const rawFile = track.file;
    const safeFile = rawFile.replace(/"/g, '\\"');
    const isUrl = rawFile.startsWith("http");

    const currentFavs = get(favorites);
    let isFav = currentFavs.has(rawFile);

    if (!isFav && isUrl) {
      const targetClean = cleanUrl(rawFile);
      for (const f of currentFavs) {
        if (cleanUrl(f) === targetClean) {
          isFav = true;
          break;
        }
      }
    }

    favorites.update((s) => {
      const newSet = new Set(s);
      if (isFav) {
        newSet.delete(rawFile);
        if (isUrl) {
          const t = cleanUrl(rawFile);
          for (const f of newSet) if (cleanUrl(f) === t) newSet.delete(f);
        }
      } else {
        newSet.add(rawFile);
      }
      return newSet;
    });

    _favActionQueue = _favActionQueue.then(async () => {
      try {
        const text = await mpdClient.send(`listplaylistinfo "${FAV_PLAYLIST}"`);
        const tracks = MpdParser.parseTracks(text);

        let matchIndices = [];

        tracks.forEach((t, i) => {
          let match = false;
          if (t.file === rawFile) match = true;
          else if (isUrl && cleanUrl(t.file) === cleanUrl(rawFile))
            match = true;
          else if (
            isUrl &&
            (t.file.includes(rawFile) || rawFile.includes(t.file))
          )
            match = true;

          if (match) matchIndices.push(i);
        });

        if (isFav) {
          if (matchIndices.length > 0) {
            matchIndices.sort((a, b) => b - a);
            for (const idx of matchIndices) {
              await mpdClient.send(`playlistdelete "${FAV_PLAYLIST}" ${idx}`);
            }
            showToast("Removed from Favorites", "info");
          }
        } else {
          if (matchIndices.length > 0) {
            console.log("[Fav] Track already exists. Skipping.");
          } else {
            await mpdClient.send(`playlistadd "${FAV_PLAYLIST}" "${safeFile}"`);
            if (tracks.length > 0) {
              await mpdClient.send(
                `playlistmove "${FAV_PLAYLIST}" ${tracks.length} 0`,
              );
            }
            showToast("Added to Favorites", "success");
          }
        }
      } catch (e) {
        console.error("Fav action failed", e);
        showToast("Action failed", "error");
      } finally {
        await this.loadFavorites();
      }
    });
  },
};

=== lib/mpd/index.js ===
import { get } from "svelte/store";
import { mpdClient } from "./client";
import { PlayerActions, startStatusPoller } from "./player";
import { LibraryActions } from "./library";
import { currentSong, stations, selectedStationName, status } from "../store";

export function connect() {
  mpdClient.connect();
  startStatusPoller();
  LibraryActions.loadPlaylists();
  LibraryActions.loadFavorites();
}

export function runMpdRequest(cmd) {
  return mpdClient.send(cmd);
}

export const {
  togglePlay,
  toggleRandom,
  toggleRepeat,
  setVolume,
  seek,
  addToQueue,
  playNext,
  removeFromQueue,
  moveTrack,
  saveQueue,
  playAllTracks,
  addAllToQueue,
} = PlayerActions;

export const {
  syncLibrary,
  loadRadioStations,
  loadPlaylists,
  openPlaylistDetails,
  toggleFavorite,
  loadFavorites,
  removeFromPlaylist,
  movePlaylistTrack,
} = LibraryActions;

export function nav(cmd) {
  const song = get(currentSong);
  const stationList = get(stations);
  const selStation = get(selectedStationName);
  const isRadioMode = song.file && song.file.startsWith("http");

  if (
    isRadioMode &&
    stationList.length > 0 &&
    (cmd === "next" || cmd === "previous")
  ) {
    let currentIndex = stationList.findIndex((s) => s.name === selStation);
    if (currentIndex === -1) currentIndex = 0;

    let nextIndex;
    if (cmd === "next") {
      nextIndex = currentIndex + 1;
      if (nextIndex >= stationList.length) nextIndex = 0;
    } else {
      nextIndex = currentIndex - 1;
      if (nextIndex < 0) nextIndex = stationList.length - 1;
    }
    playStation(stationList[nextIndex]);
  } else {
    if (cmd === "next") PlayerActions.next();
    if (cmd === "previous") PlayerActions.previous();
  }
}

export function playStation(station) {
  if (!station) return;
  selectedStationName.set(station.name);
  const streamUrl =
    station[1] || station.station || station.file || station.url;
  if (!streamUrl) return;

  PlayerActions.playUri(streamUrl, {
    title: station.name,
    artist: station.genre || "Radio Stream",
    stationName: station.name,
  });
}

export function playTrackOptimistic(track) {
  if (!track) return;
  selectedStationName.set(null);
  PlayerActions.playUri(track.file, {
    title: track.title,
    artist: track.artist,
    album: track.album,
    stationName: null,
  });
}

export async function playPlaylistContext(playlistName, index = 0) {
  if (!playlistName) return;
  selectedStationName.set(null);
  const safeName = playlistName.replace(/"/g, '\\"');
  try {
    await mpdClient.send("stop");
    await mpdClient.send("clear");
    await mpdClient.send(`load "${safeName}"`);
    await mpdClient.send(`play ${index}`);
  } catch (e) {
    console.error("Failed to play playlist context", e);
  }
}

=== lib/mpd/player.js ===
import { get } from "svelte/store";
import { mpdClient } from "./client";
import { MpdParser } from "./parser";
import {
  status,
  currentSong,
  stations,
  showToast,
  queueVersion,
  queue,
  isQueueLocked,
} from "../store";
import { db } from "../db";
import { generateUid } from "../utils";

const POLLER_INTERVAL = 1000;
const TICKER_INTERVAL = 250;

let statusPoller = null;
let playbackTicker = null;
let lastTickTime = 0;
let timeDriftSpeed = 1.0;

let isInitialSync = true;
let forceHardSync = false;
let ignoreUpdatesUntil = 0;
let queueUnlockTimer = null;

function escapePath(str) {
  if (!str) return "";
  return String(str)
    .normalize("NFC")
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"');
}

export function startStatusPoller() {
  stopStatusPoller();
  isInitialSync = true;
  forceHardSync = false;
  ignoreUpdatesUntil = 0;
  isQueueLocked.set(false);

  refreshStatus();
  statusPoller = setInterval(() => {
    if (mpdClient.isConnected && !mpdClient.isProcessing) {
      refreshStatus();
    }
  }, POLLER_INTERVAL);
}

export function stopStatusPoller() {
  if (statusPoller) {
    clearInterval(statusPoller);
    statusPoller = null;
  }
  stopTicker();
}

async function refreshStatus() {
  try {
    const statusText = await mpdClient.send("status");
    const songText = await mpdClient.send("currentsong");

    const newStatus = MpdParser.parseStatus(statusText);
    const newSong = MpdParser.parseCurrentSong(songText);

    updateStores(newStatus, newSong);

    const oldVer = get(queueVersion);
    const locked = get(isQueueLocked);

    if (locked) return;

    if (
      (newStatus.playlistLength > 0 && newStatus.playlistVersion !== oldVer) ||
      (newStatus.playlistLength > 0 && get(queue).length === 0)
    ) {
      syncQueue(newStatus.playlistVersion);
    }
  } catch (e) {
    // Silent fail on connection drops
  }
}

async function syncQueue(newVersion) {
  if (get(isQueueLocked)) return;

  try {
    const text = await mpdClient.send("playlistinfo");
    if (get(isQueueLocked)) return;

    const rawTracks = MpdParser.parseTracks(text);

    const filesToLookup = rawTracks
      .map((t) => t.file)
      .filter((f) => f && !f.startsWith("http"));

    let cachedMap = new Map();
    if (filesToLookup.length > 0) {
      try {
        cachedMap = await db.getFilesMap(filesToLookup);
      } catch (dbErr) {
        console.warn("Failed to hydrate queue from DB", dbErr);
      }
    }

    const tracks = rawTracks.map((t) => {
      const lookupKey = (t.file || "").normalize("NFC");
      const cached = cachedMap.get(lookupKey);

      if (cached) {
        return {
          ...t,
          thumbHash: cached.thumbHash,
          qualityBadge: cached.qualityBadge,
          title: t.title || cached.title,
          artist: t.artist || cached.artist,
          album: t.album || cached.album,
          _uid: String(t.id || t.pos + t.file),
        };
      }
      return {
        ...t,
        _uid: String(t.id || t.pos + t.file),
      };
    });

    queue.set(tracks);
    queueVersion.set(newVersion);
  } catch (e) {
    console.error("Queue sync error", e);
  }
}

function updateStores(serverStatus, serverSong) {
  const oldSong = get(currentSong);
  const allStations = get(stations);

  const isRadio = serverSong.file && serverSong.file.startsWith("http");
  if (isRadio) {
    const clean = (str) =>
      (str || "")
        .toString()
        .toLowerCase()
        .replace(/[^a-z0-9]/g, "");
    const targetUrl = clean(serverSong.file);
    const targetTitle = clean(serverSong.title);

    const found = allStations.find((s) => {
      const sUrl = clean(
        s.station || s.file || s.url || (Array.isArray(s) ? s[1] : ""),
      );
      const sName = clean(s.name || (Array.isArray(s) ? s[0] : ""));
      return (
        (sUrl && targetUrl.includes(sUrl)) ||
        (sName && targetTitle.includes(sName))
      );
    });

    if (found) {
      serverSong.stationName = found.name || found[0];
    } else if (oldSong.stationName && oldSong.file === serverSong.file) {
      serverSong.stationName = oldSong.stationName;
    }
  }

  currentSong.set(serverSong);

  status.update((localStatus) => {
    const isPlaying = serverStatus.state === "play";
    const now = performance.now();

    if (serverStatus.state === "pause" || localStatus.state === "pause") {
      manageTicker(false);
      return now < ignoreUpdatesUntil ? localStatus : serverStatus;
    }

    if (serverSong.file !== oldSong.file || isInitialSync) {
      isInitialSync = false;
      forceHardSync = false;
      timeDriftSpeed = 1.0;
      if (isRadio) serverStatus.elapsed = 0;
      manageTicker(isPlaying && !isRadio);
      return serverStatus;
    }

    if (now < ignoreUpdatesUntil) return localStatus;

    if (forceHardSync) {
      forceHardSync = false;
      timeDriftSpeed = 1.0;
      manageTicker(isPlaying && !isRadio);
      return serverStatus;
    }

    if (isPlaying && !isRadio) {
      const diff = serverStatus.elapsed - localStatus.elapsed;
      if (Math.abs(diff) > 2.0) {
        timeDriftSpeed = 1.0;
        return serverStatus;
      }
      if (Math.abs(diff) < 0.05) {
        timeDriftSpeed = 1.0;
      } else {
        const timeToCorrect = 1.5;
        let correction = diff / timeToCorrect;
        timeDriftSpeed = Math.max(0.5, Math.min(1.5, 1.0 + correction));
      }
      return { ...serverStatus, elapsed: localStatus.elapsed };
    }

    manageTicker(false);
    return serverStatus;
  });
}

function manageTicker(shouldRun) {
  if (shouldRun) startTicker();
  else stopTicker();
}

function startTicker() {
  if (playbackTicker || isInitialSync) return;
  lastTickTime = performance.now();
  playbackTicker = setInterval(() => {
    const now = performance.now();
    let deltaTime = (now - lastTickTime) / 1000;
    if (deltaTime > 2.0) deltaTime = 0;
    lastTickTime = now;

    status.update((s) => {
      if (s.state !== "play") return s;
      let newElapsed = s.elapsed + deltaTime * timeDriftSpeed;
      if (s.duration > 0 && newElapsed > s.duration) newElapsed = s.duration;
      return { ...s, elapsed: newElapsed };
    });
  }, TICKER_INTERVAL);
}

function stopTicker() {
  if (playbackTicker) {
    clearInterval(playbackTicker);
    playbackTicker = null;
  }
  timeDriftSpeed = 1.0;
  lastTickTime = 0;
}

async function sendTracksInChunks(tracks, playAfter = false) {
  if (!tracks || tracks.length === 0) return;

  isQueueLocked.set(true);
  forceHardSync = true;

  const CHUNK_SIZE = 5;

  try {
    for (let i = 0; i < tracks.length; i += CHUNK_SIZE) {
      const chunk = tracks.slice(i, i + CHUNK_SIZE);
      const commands = ["command_list_begin"];

      chunk.forEach((t) => {
        commands.push(`add "${escapePath(t.file)}"`);
      });
      commands.push("command_list_end");

      await mpdClient.send(commands.join("\n"));
    }

    if (playAfter) {
      await mpdClient.send("play 0");
      showToast(`Playing ${tracks.length} tracks`, "success");
    } else {
      showToast(`Added ${tracks.length} tracks`, "success");
    }
  } catch (e) {
    console.error("[Player] Bulk Action Failed:", e);
    showToast("Error adding tracks", "error");
  } finally {
    setTimeout(() => {
      isQueueLocked.set(false);
      refreshStatus();
    }, 1500);
  }
}

export const PlayerActions = {
  async togglePlay() {
    const s = get(status);
    const isPlaying = s.state === "play";
    ignoreUpdatesUntil = performance.now() + 800;
    status.update((curr) => {
      const newState = isPlaying ? "pause" : "play";
      if (newState === "play") startTicker();
      else stopTicker();
      return { ...curr, state: newState };
    });
    await mpdClient.send(isPlaying ? "pause 1" : "play");
    setTimeout(refreshStatus, 900);
  },

  async next() {
    forceHardSync = true;
    ignoreUpdatesUntil = 0;
    await mpdClient.send("next");
    refreshStatus();
  },

  async previous() {
    forceHardSync = true;
    ignoreUpdatesUntil = 0;
    status.update((s) => ({ ...s, elapsed: 0 }));
    await mpdClient.send("previous");
    refreshStatus();
  },

  async setVolume(val) {
    status.update((s) => ({ ...s, volume: val }));
    await mpdClient.send(`setvol ${val}`);
  },

  async seek(seconds) {
    forceHardSync = true;
    ignoreUpdatesUntil = performance.now() + 500;
    status.update((s) => ({ ...s, elapsed: seconds }));
    await mpdClient.send(`seekcur ${seconds}`);
    setTimeout(refreshStatus, 600);
  },

  async toggleRandom() {
    const s = get(status);
    const newVal = !s.random;
    status.update((curr) => ({ ...curr, random: newVal }));
    await mpdClient.send(`random ${newVal ? 1 : 0}`);
  },

  async toggleRepeat() {
    const s = get(status);
    const newVal = !s.repeat;
    status.update((curr) => ({ ...curr, repeat: newVal }));
    await mpdClient.send(`repeat ${newVal ? 1 : 0}`);
  },

  async playUri(uri, meta = {}) {
    isQueueLocked.set(true);
    const safeUri = escapePath(uri);
    forceHardSync = true;

    status.update((s) => ({ ...s, state: "play", elapsed: 0 }));
    currentSong.set({
      title: meta.title || uri.split("/").pop(),
      artist: meta.artist || "",
      file: uri,
    });
    startTicker();

    try {
      await mpdClient.send("stop");
      await mpdClient.send("clear");
      await mpdClient.send(`add "${safeUri}"`);
      await mpdClient.send("play");
    } catch (e) {
      console.error("Play error", e);
      showToast("Failed to play", "error");
    }

    setTimeout(() => {
      isQueueLocked.set(false);
      refreshStatus();
    }, 1200);
  },

  async addToQueue(uri) {
    try {
      await mpdClient.send(`add "${escapePath(uri)}"`);
      showToast("Added to queue", "success");
    } catch (e) {
      console.error("Add queue error", e);
      showToast("Failed to add", "error");
    }
  },

  async playNext(uri) {
    isQueueLocked.set(true);
    const safeUri = escapePath(uri);
    try {
      const songData = await mpdClient.send("currentsong");
      const currentPos = parseInt(MpdParser.parseKeyValue(songData).pos || -1);

      if (currentPos === -1) {
        isQueueLocked.set(false);
        await this.playUri(uri);
      } else {
        const res = await mpdClient.send(`addid "${safeUri}"`);
        const newId = parseInt(MpdParser.parseKeyValue(res).id);

        if (!isNaN(newId)) {
          await mpdClient.send(`moveid ${newId} ${currentPos + 1}`);
          showToast("Will play next", "success");
        }
        setTimeout(() => isQueueLocked.set(false), 1000);
      }
    } catch (e) {
      console.error("Play Next error", e);
      showToast("Failed to set next", "error");
      isQueueLocked.set(false);
    }
  },

  async removeFromQueue(pos) {
    isQueueLocked.set(true);
    if (queueUnlockTimer) clearTimeout(queueUnlockTimer);

    try {
      queue.update((q) => {
        const copy = [...q];
        copy.splice(pos, 1);
        return copy;
      });
      await mpdClient.send(`delete ${pos}`);
    } catch (e) {
      showToast("Failed to remove", "error");
      isQueueLocked.set(false);
      return;
    }
    queueUnlockTimer = setTimeout(() => {
      isQueueLocked.set(false);
    }, 1000);
  },

  async moveTrack(fromPos, toPos) {
    if (fromPos === toPos) return;

    isQueueLocked.set(true);
    if (queueUnlockTimer) clearTimeout(queueUnlockTimer);

    try {
      await mpdClient.send(`move ${fromPos} ${toPos}`);
    } catch (e) {
      console.error("Move failed", e);
      showToast("Move failed", "error");
      isQueueLocked.set(false);
      refreshStatus();
      return;
    }

    queueUnlockTimer = setTimeout(() => {
      isQueueLocked.set(false);
      refreshStatus();
    }, 2000);
  },

  async playAllTracks(tracks) {
    if (!tracks || tracks.length === 0) return;
    try {
      await mpdClient.send("stop");
      await mpdClient.send("clear");
      await sendTracksInChunks(tracks, true);
    } catch (e) {
      console.error(e);
    }
  },

  async addAllToQueue(tracks) {
    if (!tracks || tracks.length === 0) return;
    await sendTracksInChunks(tracks, false);
  },

  async saveQueue(name) {
    if (!name) return;
    const safeName = name.replace(/"/g, '\\"');
    try {
      await mpdClient.send(`save "${safeName}"`);
      showToast(`Playlist "${name}" saved`, "success");
    } catch (e) {
      if (e.message.includes("exist")) {
        if (confirm(`Playlist "${name}" exists. Overwrite?`)) {
          try {
            await mpdClient.send(`rm "${safeName}"`);
            await mpdClient.send(`save "${safeName}"`);
            showToast(`Playlist "${name}" overwritten`, "success");
          } catch (err) {
            showToast("Failed to overwrite", "error");
          }
        }
      } else {
        console.error(e);
      }
    }
  },
};

=== lib/mpd/client.js ===
import { CONFIG } from "../../config";
import { connectionStatus, showToast } from "../store";

class MpdClient {
  constructor() {
    this.socket = null;
    this.queue = [];
    this.isProcessing = false;
    this.reconnectTimer = null;
    this.watchdogTimer = null;
    this._buffer = "";
  }

  get isConnected() {
    return this.socket && this.socket.readyState === WebSocket.OPEN;
  }

  connect() {
    if (
      this.socket &&
      (this.socket.readyState === WebSocket.CONNECTING ||
        this.socket.readyState === WebSocket.OPEN)
    ) {
      return;
    }

    if (this.reconnectTimer) clearTimeout(this.reconnectTimer);

    let host = CONFIG.MOODE_IP || window.location.hostname;
    host = host
      .replace(/^https?:\/\//, "")
      .split(":")[0]
      .split("/")[0];
    const port = CONFIG.WS_PORT || "8080";
    const wsUrl = `ws://${host}:${port}`;

    console.log("[MPD] Connecting to:", wsUrl);

    try {
      this.socket = new WebSocket(wsUrl, ["binary"]);
    } catch (e) {
      console.error("[MPD] Connection Error:", e);
      this.reconnectTimer = setTimeout(() => this.connect(), 5000);
      return;
    }

    this.socket.onopen = () => {
      console.log("[MPD] Connected");
      connectionStatus.set("Connected");
      showToast("Connected to Moode", "success");
      this._processQueue();
    };

    this.socket.onmessage = (event) => this._handleMessage(event);

    this.socket.onclose = (e) => {
      console.warn("[MPD] Socket closed", e.code, e.reason);
      connectionStatus.set("Disconnected");
      this._cleanup();
      this.reconnectTimer = setTimeout(() => this.connect(), 3000);
    };

    this.socket.onerror = (err) => {
      console.error("[MPD] Socket error", err);
    };
  }

  send(cmd) {
    return new Promise((resolve, reject) => {
      this.queue.push({ cmd, resolve, reject });
      this._processQueue();
    });
  }

  _cleanup() {
    this.isProcessing = false;
    this._buffer = "";
    if (this.watchdogTimer) clearTimeout(this.watchdogTimer);

    while (this.queue.length > 0) {
      const { reject } = this.queue.shift();
      reject(new Error("Connection lost"));
    }
  }

  async _processQueue() {
    if (this.isProcessing || this.queue.length === 0 || !this.isConnected)
      return;

    this.isProcessing = true;
    const { cmd } = this.queue[0];

    // Таймаут 20с для больших запросов (например, playlistinfo)
    if (this.watchdogTimer) clearTimeout(this.watchdogTimer);
    this.watchdogTimer = setTimeout(() => {
      console.error("[MPD] Watchdog timeout");
      if (this.socket) this.socket.close();
    }, 20000);

    try {
      const payload = cmd.endsWith("\n") ? cmd : cmd + "\n";
      this.socket.send(new TextEncoder().encode(payload));
    } catch (e) {
      console.error("[MPD] Send error", e);
      this._cleanup();
    }
  }

  async _handleMessage(event) {
    let text = event.data;
    if (text instanceof Blob) {
      text = await text.text();
    }

    if (this.watchdogTimer) {
      clearTimeout(this.watchdogTimer);
      this.watchdogTimer = null;
    }

    // Всегда добавляем в буфер
    this._buffer += text;

    const isSuccess =
      this._buffer.endsWith("\nOK\n") || this._buffer === "OK\n";
    const isError = this._buffer.startsWith("ACK");

    if (isSuccess || isError) {
      const fullResponse = this._buffer;
      this._buffer = ""; // Очистка буфера

      const currentRequest = this.queue.shift();
      this.isProcessing = false;

      if (currentRequest) {
        if (isError) {
          console.error(`[MPD] Error: ${fullResponse.trim()}`);
          currentRequest.reject(new Error(fullResponse.trim()));
        } else {
          const cleanResult = fullResponse
            .replace(/\nOK\n$/, "")
            .replace(/^OK\n$/, "");
          currentRequest.resolve(cleanResult);
        }
      }

      this._processQueue();
    } else {
      // Если ответ не завершен, перезапускаем таймер, чтобы не разорвать соединение
      if (!this.queue.length) return;

      this.watchdogTimer = setTimeout(() => {
        console.error("[MPD] Watchdog timeout receiving large data");
        if (this.socket) this.socket.close();
      }, 20000);
    }
  }
}

export const mpdClient = new MpdClient();

=== lib/mpd/parser.js ===
/**
 * Robust MPD Parser.
 * Handles parsing iteratively to avoid memory spikes on large libraries.
 */
export const MpdParser = {
  parseKeyValue(text) {
    const result = {};
    if (!text) return result;

    const lines = text.split("\n");
    for (const line of lines) {
      const idx = line.indexOf(": ");
      if (idx === -1) continue;
      // ВАЖНО: приводим ключ к нижнему регистру
      const key = line.substring(0, idx).toLowerCase();
      const val = line.substring(idx + 2);
      result[key] = val;
    }
    return result;
  },

  parseStatus(text) {
    const data = this.parseKeyValue(text);
    let format = "";
    if (data.audio) {
      const parts = data.audio.split(":");
      if (parts[1]) {
        format = `${parts[1]}-bit`;
      }
    }
    return {
      state: data.state || "stop",
      volume: parseInt(data.volume) || 0,
      elapsed: parseFloat(data.elapsed) || 0,
      duration: parseFloat(data.duration) || 0,
      random: data.random === "1",
      repeat: data.repeat === "1",
      songId: parseInt(data.songid) || -1,
      playlistLength: parseInt(data.playlistlength) || 0,
      bitrate: parseInt(data.bitrate) || 0,
      format: format,
      playlistVersion: parseInt(data.playlist) || 0,
    };
  },

  parseCurrentSong(text) {
    const data = this.parseKeyValue(text);
    return this._normalizeTrack(data);
  },

  parsePlaylists(text) {
    const lines = text.split("\n");
    const items = [];
    let current = null;

    for (const line of lines) {
      if (line.startsWith("playlist: ")) {
        if (current) items.push(current);
        current = { playlist: line.substring(10) };
      } else if (line.startsWith("Last-Modified: ") && current) {
        current["last-modified"] = line.substring(15);
      }
    }
    if (current) items.push(current);
    return items.map((i) => ({
      name: i.playlist,
      lastModified: i["last-modified"],
    }));
  },

  /**
   * STREAMING-LIKE PARSER FOR TRACKS
   */
  parseTracks(rawText) {
    const tracks = [];
    let currentTrack = null;

    let start = 0;
    let end = rawText.indexOf("\n", start);

    while (end !== -1) {
      const line = rawText.substring(start, end);
      const sepIndex = line.indexOf(": ");

      if (sepIndex !== -1) {
        // ВАЖНО: Lowercase key
        const key = line.substring(0, sepIndex).toLowerCase();
        const value = line.substring(sepIndex + 2);

        if (key === "file") {
          if (currentTrack) {
            tracks.push(this._normalizeTrack(currentTrack));
          }
          currentTrack = { file: value };
        } else if (currentTrack) {
          currentTrack[key] = value;
        }
      }

      start = end + 1;
      end = rawText.indexOf("\n", start);
    }

    if (currentTrack) {
      tracks.push(this._normalizeTrack(currentTrack));
    }

    return tracks;
  },

  _normalizeTrack(raw) {
    // raw ключи уже lowercase, если пришли через parseKeyValue,
    // но parseTracks заполняет их как есть, поэтому проверяем оба варианта
    const file = raw.file || raw.File || "";
    const title =
      raw.Title ||
      raw.title ||
      raw.Name ||
      raw.name ||
      file.split("/").pop() ||
      "Unknown";

    return {
      file: file,
      title: title,
      artist: raw.Artist || raw.artist || "Unknown Artist",
      album: raw.Album || raw.album || "Unknown Album",
      genre: raw.Genre || raw.genre || "Unknown",
      time: parseFloat(raw.Time || raw.time || 0),
      track: raw.Track || raw.track || "",
      id: raw.Id || raw.id,
      stationName: raw.name || raw.Name || null,
    };
  },
};

=== lib/actions.js ===
export function longpress(node, duration = 2000) {
  let timer;

  const handleStart = (e) => {
    // Игнорируем правый клик
    if (e.type === "mousedown" && e.button !== 0) return;

    timer = setTimeout(() => {
      node.dispatchEvent(
        new CustomEvent("longpress", {
          detail: { originalEvent: e },
        }),
      );
    }, duration);
  };

  const handleEnd = () => {
    clearTimeout(timer);
  };

  node.addEventListener("mousedown", handleStart);
  node.addEventListener("touchstart", handleStart, { passive: true });

  node.addEventListener("mouseup", handleEnd);
  node.addEventListener("mouseleave", handleEnd);
  node.addEventListener("touchend", handleEnd);
  node.addEventListener("touchcancel", handleEnd);
  node.addEventListener("touchmove", handleEnd);

  return {
    destroy() {
      node.removeEventListener("mousedown", handleStart);
      node.removeEventListener("touchstart", handleStart);
      node.removeEventListener("mouseup", handleEnd);
      node.removeEventListener("mouseleave", handleEnd);
      node.removeEventListener("touchend", handleEnd);
      node.removeEventListener("touchcancel", handleEnd);
      node.removeEventListener("touchmove", handleEnd);
    },
  };
}

=== lib/theme.js ===
export const THEME = {
  COLORS: {
    PRIMARY: "#fa2d48", // Moode Red
    BACKGROUND: "#121212",
    SURFACE: "#1a1a1a",
    SURFACE_LIGHT: "#2a2a2a",
    TEXT_MAIN: "#ffffff",
    TEXT_DIMMED: "#888888",
    TEXT_MUTED: "#444444",
    BORDER: "rgba(255, 255, 255, 0.1)",
    SKELETON: "rgba(255, 255, 255, 0.1)",
  },
  SPACING: {
    MINI_PLAYER_HEIGHT: "90px",
    TOP_BAR_HEIGHT: "64px",
    VIEW_PADDING: "32px",
    VIEW_PADDING_MOBILE: "16px",
  },
  ANIMATION: {
    DURATION_FAST: "200ms",
    DURATION_NORMAL: "300ms",
  },
};

=== lib/utils.js ===
export function getStationImageUrl(station) {
  if (!station || !station.image) return null;

  if (station.image.startsWith("http")) {
    return station.image;
  }

  let filename = "";
  if (station.image === "local") {
    filename = `${station.name}.jpg`;
  } else {
    filename = station.image;
  }

  const safeFilename = encodeURIComponent(filename);
  return `/imagesw/radio-logos/thumbs/${safeFilename}`;
}

export function getCoverUrl(song) {
  if (!song || !song.file) return null;

  if (!song.file.startsWith("http")) {
    return `/coverart.php?u=${encodeURIComponent(song.file)}`;
  }

  return null;
}

export function generateUid() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

=== lib/constants.js ===
import { CONFIG } from "../config";

export const DATABASE = {
  NAME: "MoodePlayerDB",
  STORE_NAME: "music",
  VERSION: 3,
};

export const API_ENDPOINTS = {
  SYNC: `/wave-api.php`,
  STATIONS: (isDev) => `/wave-api.php?action=stations`,
  COVER_ART: (file) => `/coverart.php?u=${encodeURIComponent(file)}`,
  RADIO_LOGOS: (filename) => `/imagesw/radio-logos/thumbs/${filename}`,
};

export const PLAYER_CONFIG = {
  POLLER_INTERVAL: 1000,
  TICKER_INTERVAL: 250,
  UI_LOCK_SHORT: 500,
  UI_LOCK_LONG: 800,
  UI_LOCK_SYNC: 1000,
  RECONNECT_DELAY: 3000,
  WATCHDOG_TIMEOUT: 5000,
};

export const FAVORITES_PLAYLIST = "Favorites";

=== lib/store.js ===
import { writable, derived, get } from "svelte/store";
import { CONFIG } from "../config";
import { getStationImageUrl } from "./utils";
import md5 from "md5";

export const connectionStatus = writable("Disconnected");

export const toastMessage = writable(null);
let toastTimer;

export function showToast(msg, type = "info") {
  toastMessage.set({ text: msg, type });
  if (toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    toastMessage.set(null);
  }, 3000);
}

export const status = writable({
  state: "stop",
  volume: 50,
  elapsed: 0,
  duration: 0,
  random: false,
  repeat: false,
  bitrate: 0,
  format: "",
});

export const currentSong = writable({
  title: "Not Playing",
  artist: "",
  album: "",
  file: "",
  stationName: null,
});

// UI
export const isFullPlayerOpen = writable(false);
export const isLoadingRadio = writable(false);
export const isLoadingPlaylists = writable(false);
export const isLoadingTracks = writable(false);
export const activeMenuTab = writable("library");
export const selectedStationName = writable(null);
export const isSyncingLibrary = writable(false);

// --- SIDEBAR PERSISTENCE START ---
const storedSidebar = localStorage.getItem("sidebarCollapsed") === "true";
export const isSidebarCollapsed = writable(storedSidebar);

// Подписываемся на изменения, чтобы сохранять в localStorage
isSidebarCollapsed.subscribe((val) => {
  if (typeof localStorage !== "undefined") {
    localStorage.setItem("sidebarCollapsed", String(val));
  }
});
// --- SIDEBAR PERSISTENCE END ---

// Library
export const stations = writable([]);
export const playlists = writable([]);
export const activePlaylistTracks = writable([]);
export const activePlaylistName = writable(null);
export const favorites = writable(new Set());
export const isQueueLocked = writable(false);

// Navigation
export const navigationStack = writable([{ view: "root" }]);
export const queue = writable([]);
export const queueVersion = writable(0);
export const searchQuery = writable("");

// Scroll
export const scrollPositions = writable({});
export function saveScrollPosition(key, pos) {
  scrollPositions.update((s) => ({ ...s, [key]: pos }));
}
export function getScrollPosition(key) {
  return get(scrollPositions)[key] || 0;
}

export const contextMenu = writable({
  isOpen: false,
  track: null,
  context: { type: "general", playlistName: null, index: null },
  x: 0,
  y: 0,
  triggerRect: null,
});

export const playlistSelector = writable({
  isOpen: false,
  track: null,
});

function vibrate() {
  if (typeof navigator !== "undefined" && navigator.vibrate) {
    try {
      navigator.vibrate(70);
    } catch (e) {
      // ignore
    }
  }
}

export function openContextMenu(e, track, contextData = {}) {
  if (!track) return;
  vibrate();

  let clientX = 0;
  let clientY = 0;
  let rect = null;

  let el = e.currentTarget;
  if (!el && e.target && e.target.closest) {
    el = e.target.closest("button") || e.target;
  }

  if (el && el.getBoundingClientRect) {
    rect = el.getBoundingClientRect();
  }

  const evt = e.detail?.originalEvent || e;
  if (evt.touches && evt.touches.length > 0) {
    clientX = evt.touches[0].clientX;
    clientY = evt.touches[0].clientY;
  } else if (evt.clientX) {
    clientX = evt.clientX;
    clientY = evt.clientY;
  }

  const ctx = {
    type: "general",
    playlistName: null,
    index: null,
    ...contextData,
  };

  contextMenu.set({
    isOpen: true,
    track,
    context: ctx,
    x: clientX,
    y: clientY,
    triggerRect: rect,
  });
}

export function closeContextMenu() {
  contextMenu.set({
    isOpen: false,
    track: null,
    context: {},
    x: 0,
    y: 0,
    triggerRect: null,
  });
}

export function openPlaylistSelector(track) {
  closeContextMenu();
  playlistSelector.set({ isOpen: true, track });
}

export function closePlaylistSelector() {
  playlistSelector.set({ isOpen: false, track: null });
}

// Routing
let pendingRouteData = null;
let onNavigateCallback = null;

export function setNavigationCallback(fn) {
  onNavigateCallback = fn;
}

export function navigateTo(view, data = null) {
  if (data) pendingRouteData = data;

  if (onNavigateCallback) {
    onNavigateCallback(view, data);
  } else {
    console.warn("Router callback not set!");
  }
}

export function consumeRouteData() {
  const d = pendingRouteData;
  pendingRouteData = null;
  return d;
}

export function navigateBack() {
  window.history.back();
}

export function handleBrowserBack() {
  // Placeholder
}

// FULL SIZE (for player)
export function getTrackCoverUrl(
  track,
  stationList = [],
  selectedRadioName = null,
) {
  if (!track || !track.file) return "/images/default_cover.png";

  if (isRadioTrack(track.file) || track.genre === "Radio") {
    if (track.image) {
      return getStationImageUrl(track);
    }
    return (
      resolveRadioImage(track, stationList, selectedRadioName) ||
      "/images/radio_placeholder.png"
    );
  }

  let cleanPath = track.file.startsWith("/") ? track.file.slice(1) : track.file;
  return `/coverart.php/${encodeURI(cleanPath)}`;
}

export function getTrackThumbUrl(
  track,
  size = "sm",
  stationList = [],
  selectedRadioName = null,
) {
  // Handle Radio
  if (
    !track ||
    (track.file &&
      (isRadioTrack(track.file) ||
        track.genre === "Radio" ||
        Array.isArray(track)))
  ) {
    if (track && track.image) {
      return getStationImageUrl(track);
    }
    return (
      resolveRadioImage(track, stationList, selectedRadioName) ||
      "/images/radio_icon.png"
    );
  }

  if (!track.file) return "/images/default_icon.png";

  // New Logic: Use thumbHash if available
  if (track.thumbHash) {
    const suffix = size === "md" ? "" : "_sm";
    return `/imagesw/thmcache/${track.thumbHash}${suffix}.jpg`;
  }

  // Fallback for legacy DB or uncached items
  try {
    const lastSlashIndex = track.file.lastIndexOf("/");
    const dirPath =
      lastSlashIndex === -1 ? "." : track.file.substring(0, lastSlashIndex);
    const hash = md5(dirPath);
    const suffix = size === "md" ? "" : "_sm";
    return `/imagesw/thmcache/${hash}${suffix}.jpg`;
  } catch (e) {
    let cleanPath = track.file.startsWith("/")
      ? track.file.slice(1)
      : track.file;
    return `/coverart.php/${encodeURI(cleanPath)}`;
  }
}

function isRadioTrack(file) {
  if (!file) return false;
  return (
    file.startsWith("http") || file.includes("://") || file.includes("RADIO")
  );
}

function resolveRadioImage(track, stationList, selectedRadioName) {
  const normalize = (str) =>
    (str || "")
      .toString()
      .toLowerCase()
      .replace(/[^a-z0-9]/g, "");

  const targetTitle = normalize(track?.title);
  const targetStationName = normalize(track?.stationName);
  const targetSelected = normalize(selectedRadioName);

  if (stationList && stationList.length > 0) {
    const found = stationList.find((s) => {
      const sName = normalize(s.name);
      if (!sName) return false;
      return (
        sName === targetStationName ||
        sName === targetSelected ||
        (targetTitle && sName === targetTitle) ||
        (targetTitle && targetTitle.includes(sName) && sName.length > 3)
      );
    });
    if (found) return getStationImageUrl(found);
  }

  const fallbackName = track?.stationName || selectedRadioName;
  if (fallbackName) {
    return getStationImageUrl({ name: fallbackName, image: "local" });
  }
  return null;
}

export const currentCover = derived(
  [currentSong, stations, selectedStationName],
  ([$song, $stations, $selectedName]) => {
    return getTrackCoverUrl($song, $stations, $selectedName);
  },
);

export const currentArtistImage = derived(currentSong, ($song) => {
  if (!$song || !$song.file) return null;
  if ($song.file.startsWith("http")) return null;
  return `/coverart.php/${encodeURI($song.file)}`;
});

export const coverUrl = currentCover;

